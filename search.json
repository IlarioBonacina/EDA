[
  {
    "objectID": "theory_bits/sorting_algorithms.html",
    "href": "theory_bits/sorting_algorithms.html",
    "title": "Some Elementary Sorting Algorithms",
    "section": "",
    "text": "We recall some basic facts on some elementary comparison-based sorting algorithms. These are sorting algorithms that only operate on the input array/vector by comparing pairs of elements and moving elements around based on the results of these comparisons.\nThe following tabs are about some comparison-based sorting algorithms, each contains a simple implementation of the algorithm with a reminder of the running time. You can find the implementations (and many more) also in Algorithms in C++.\n\nSelection-sortInsertion-sortMerge-SortQuick-SortHeap-sort\n\n\nThe Selection-sort algorithm divides the input vector into two parts: a sorted subvector of items which is built up from left to right at the front (left) of the vector and a subvector of the remaining unsorted items that occupy the rest of the vector.\nInitially, the sorted subvector is empty and the unsorted subvector is the entire input vector. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted subvector, exchanging (swapping) it with the leftmost unsorted element (putting it in sorted order), and moving the subvector boundaries one element to the right.\n\n\n\n\n\nSelection sort animation.Red is current min.Yellow is sorted list.Blue is current item.\n\n\n\n\n\ntemplate &lt;typename elem&gt;\n\nvoid sel_sort (vector&lt;elem&gt;& v) {\n    int n = v.size();\n    for (int i = 0; i &lt; n - 1; ++i) {\n        int p = pos_min(v, i, n-1);\n        swap(v[i], v[p]);\n    } \n}\n\ntemplate &lt;typename elem&gt;\n\nint pos_min (vector&lt;elem&gt;& v, int l, int r) {\n    int p = l;\n    for (int j = l + 1; j &lt;= r; ++j) {\n        if (v[j] &lt; v[p]) p = j; \n    }\n    return p;\n}\n\n\n\n\nInsertion sort iterates, consuming one input element each repetition, and grows a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted vector, and inserts it there. It repeats until no input elements remain.\n\n\n\n\n\nInsertion sort animation\n\n\n\n\n\ntemplate &lt;class T&gt;\n\nvoid insertion_sort (vector&lt;T&gt;& v) {\n    int n = v.size();\n    for (int i = 1; i &lt; n; ++i) {\n        for (int j = i; j &gt; 0 and v[j - 1] &gt; v[j]; --j) {\n            swap(v[j - 1], v[j]);\n        } \n    } \n}\n\n\n\n\nMerge sort is a divide-and-conquer algorithm that was invented by John von Neumann in 1945. Conceptually, a merge sort works as follows:\n\nDivide the unsorted list into n sublists, each containing one element (a list of one element is considered sorted).\nRepeatedly merge sublists to produce new sorted sublists until there is only one sublist remaining. This will be the sorted list.\n\n\n\n\n\n\nAn example of merge sort. First, divide the list into the smallest unit (1 element), then compare each element with the adjacent list to sort and merge the two adjacent lists. Finally, all the elements are sorted and merged.\n\n\n\n\n\ntemplate &lt;class T&gt;\n\nvoid mergesort (vector&lt;T&gt;& v) {\n    mergesort(v, 0, v.size() - 1);\n}\n\nvoid mergesort (vector&lt;T&gt;& v, int l, int r) {\n    if (l &lt; r) {\n        int m = (l + r) / 2;\n        mergesort(v, l, m);\n        mergesort(v, m + 1, r);\n        merge(v, l, m, r);\n    } \n}\n\nvoid merge (vector&lt;T&gt;& v, int l, int m, int r) {\n    vector&lt;T&gt; b(r - l + 1);\n    int i = l, j = m + 1, k = 0;\n    while (i &lt;= m and j &lt;= r) {\n        if (v[i] &lt;= v[j]) b[k++] = v[i++];\n        else b[k++] = v[j++];\n    }\n    while (i &lt;= m) b[k++] = v[i++];\n    while (j &lt;= r) b[k++] = v[j++];\n    for (k = 0; k &lt;= r - l; ++k) v[l + k] = b[k];\n}\n\n\n\n\nQuicksort was developed by British computer scientist Tony Hoare in 1959 and published in 1961. It is still a commonly used algorithm for sorting. Overall, it is slightly faster than merge sort and heapsort for randomized data, particularly on larger distributions.\nQuicksort is a type of divide-and-conquer algorithm for sorting an array, based on a partitioning routine; the details of this partitioning can vary somewhat, so that quicksort is really a family of closely related algorithms.\nApplied to a range of at least two elements, partitioning produces a division into two consecutive non empty sub-ranges, in such a way that no element of the first sub-range is greater than any element of the second sub-range. After applying this partition, quicksort then recursively sorts the sub-ranges, possibly after excluding from them an element at the point of division that is at this point known to be already in its final location. Due to its recursive nature, quicksort (like the partition routine) has to be formulated so as to be callable for a range within a larger array, even if the ultimate goal is to sort a complete array.\nThe choice of partition routine (including the pivot selection) and other details can affect the algorithm’s performance, possibly to a great extent for specific input arrays.\n\n\n\n\n\nAnimated visualization of the quicksort algorithm. The horizontal lines are pivot values.\n\n\n\n\n\ntemplate &lt;class T&gt;\n\nvoid partition(vector&lt;T&gt;& v, int l, int u, int& k) {\n    int i = l+1;\n    int j = u;\n    T pv = v[i]; // simple choice for pivot\n    while (i &lt; j+1) {\n        while (i &lt; j+1 and v[i] &lt;= pv) ++i;\n        while (i &lt; j+1 and pv &lt;= v[j]) --j;\n        if (i &lt; j + 1) {\n            swap(v[i], v[j]);\n            ++i; \n            --j;\n        }\n    }\n    swap(v[l], v[j]);\n    k = j;\n}\n\nvoid quicksort(vector&lt;T&gt;& v, int l, int u) {\n    if (u -l + 1 &gt; M) {\n        int k;\n        partition(v, l, u, k);\n        quicksort(v, l, k-1);\n        quicksort(v, k+1, u);\n    }\n}\n\nvoid quicksort(vector&lt;T&gt;& v) {\n    quicksort(v, 0, v.size()-1);\n    insertion_sort(v, 0, v.size()-1);\n}\n\n\n\n\nHeap-sort was invented by J. W. J. Williams in 1964 and it can be thought of as\n\n“an implementation of selection sort using the right data structure.”\n(Skiena, Steven)\n\nLike selection sort, heapsort divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element from it and inserting it into the sorted region. Unlike selection sort, heapsort does not waste time with a linear-time scan of the unsorted region; rather, heap sort maintains the unsorted region in a heap data structure to efficiently find the largest element in each step.\n\n\n\n\n\nA run of heapsort sorting an array of randomly permuted values. In the first stage of the algorithm the array elements are reordered to satisfy the heap property. Before the actual sorting takes place, the heap tree structure is shown briefly for illustration.\n\n\n\n\n\n#include &lt;queue&gt;\n\ntemplate &lt;class T&gt;\n\nvoid heapsort (vector&lt;T&gt;& v) {\n    int n = v.size();\n    priority_queue&lt;T&gt; pq;\n    for (int i = 0; i &lt; n; ++i) {\n        pq.push(v[i]);\n    }\n    for (int i = n-1; i &gt;= 0; --i) {\n        v[i] = pq.top();\n        pq.pop();\n    } \n}\n\n\n\n\n\nThe following table compares the running times in the worst, best and average case of the ordering algorithms above as functions of the number of elements n of the input vector.\n\n\n\n\n\n\n\n\n\nAlgorithm\nWorst case\nBest Case\nAverage case\n\n\n\n\nSelection-sort\n\\Theta(n^2)\n\\Theta(n^2)\n\\Theta(n^2)\n\n\nInsertion-sort\n\\Theta(n^2)\n\\Theta(n) (The best case input is a vector that is already sorted.)\n\\Theta(n^2)\n\n\nMerge-sort\n\\Theta(n\\log n)\n\\Theta(n\\log n)Merge sort’s best case takes about half as many iterations as its worst case.\n\\Theta(n\\log n)\n\n\nQuick-sort\n\\Theta(n^2)\n\\Theta(n\\log n) (simple partition)\n\\Theta(n\\log n)\n\n\nHeap-sort\n\\Theta(n\\log n)\n\\Theta(n\\log n)  distinct keys\n\\Theta(n\\log n)\n\n\n\n\n\n\n\n\n\nComparison-based sorting algorithm\n\n\n\nA comparison-based sorting algorithm takes as input an array/vector [a_1,a_2,\\dots ,a_n] of n items, and can only gain information about the items by comparing pairs of them. Each comparison is of the form \n\\text{$a_i &gt; a_j$?}\n\nand returns YES or NO and counts a 1 time-step. The algorithm may also for free reorder items based on the results of comparisons made. In the end, the algorithm must output a permutation of the input in which all items are in sorted order (say increasingly).\n\n\nFor instance, Quicksort, Mergesort, and Insertion-sort are all comparison-based sorting algorithms. How efficient can be comparison-based sorting algorithms?\n\n\n\n\n\n\nTheorem\n\n\n\nAny deterministic comparison-based sorting algorithm must perform \\Omega(n \\log n) comparisons to sort n elements in the worst case.\nMore precisely, for any deterministic comparison-based sorting algorithm A, for all n \\geq 2 there exists an input I of size n such that A makes at least \\log_2(n!) = \\Omega(n \\log n) comparisons to sort I.\n\n\nTo prove this theorem, we cannot assume the sorting algorithm is going to necessarily choose a pivot as in Quicksort, or split the input as in Mergesort — we need to analyze any possible (comparison-based) algorithm that might exist.\n\n\n\n\n\n\nProof (sketch)\n\n\n\n\n\nFor a deterministic algorithm, the permutation it outputs is solely a function of the series of answers it receives (any two inputs producing the same series of answers will cause the same permutation to be output). So, if an algorithm always made at most k &lt; \\log_2(n!) comparisons, then there are at most 2^k &lt; n! diﬀerent permutations it can possibly output. But the total number of possible permutations is n!. So, there is some permutation it can’t output and the algorithm will fail on any input for which that permutation is the only correct answer.\n\n\n\nThe theorem above actually holds for randomized algorithms too, but the argument is a bit more subtle."
  },
  {
    "objectID": "theory_bits/logs.html",
    "href": "theory_bits/logs.html",
    "title": "Basic properties of logarithms and factorials",
    "section": "",
    "text": "This theory bit recalls some basic properties of two special functions, the logarithm and the factorial."
  },
  {
    "objectID": "theory_bits/logs.html#logarithms",
    "href": "theory_bits/logs.html#logarithms",
    "title": "Basic properties of logarithms and factorials",
    "section": "Logarithms",
    "text": "Logarithms\nRecall that, for each b\\in \\mathbb R_+\\setminus \\{1\\}, the logarithm in base b (denoted as \\log_b(\\cdot)) is the unique function from \\mathbb R_+ to \\mathbb R such that \n\\log_b(b^x)=b^{\\log_b(x)}=x\\ .\n In particular, \\log_2(2^x)=2^{\\log_2(x)}=x and \\ln(e^x)=e^{\\ln(x)}=x, since \\ln(\\cdot) is just an alias of \\log_e(\\cdot).\nIt follows immediately from the definition (how?) that\n\n\\log_b(xy)=\\log_b(x)+\\log_b(y)\nfor all a,b\\in \\mathbb R_+\\setminus \\{1\\}, \\displaystyle\\log_a(x)=\\frac{\\log_b(x)}{\\log_b(a)}.\nfor every r\\in \\mathbb R, \\displaystyle\\log_b(x^r)=r\\log_b(x).\n\n\n\n\n\n\n\nLogarithms grow more slowly than any power or root of x\n\n\n\n\n\\lim_{x\\to \\infty}\\frac{\\log_a(x)}{x^b}=0\\,\n for all b&gt; 0."
  },
  {
    "objectID": "theory_bits/logs.html#the-factorial",
    "href": "theory_bits/logs.html#the-factorial",
    "title": "Basic properties of logarithms and factorials",
    "section": "The factorial",
    "text": "The factorial\nThe factorial of a natural number n (denoted as n!) is the number of different possible ways of arranging n distinct obects into a sequence. (0!=1)\nFactorials exhibit a quite fast growth as the Stirling approximation shows.\n\n\n\n\n\n\nStirling’s approximation\n\n\n\n\nn!\\sim\\sqrt{2\\pi n} \\left(\\frac{n}{e}\\right)^n\\ ,\n where \\sim means that the ratio of n! and \\sqrt{2\\pi n} \\left(\\frac{n}{e}\\right)^n tends to 1 as n\\to +\\infty. More precisely, \nn!=\\sqrt{2\\pi n} \\left(\\frac{n}{e}\\right)^n\\left(1+O\\left(\\frac{1}{n}\\right)\\right)\\ .\n\nThe O\\left(\\frac{1}{n}\\right) in the equality above is hiding terms that for all large n are at most proportional to \\frac{1}{n}. Indeed, the equality above using more terms would be \n{\\displaystyle n!\\sim {\\sqrt {2\\pi n}}\\left({\\frac {n}{e}}\\right)^{n}\\left(1+{\\frac {1}{12n}}+{\\frac {1}{288n^{2}}}-{\\frac {139}{51840n^{3}}}-{\\frac {571}{2488320n^{4}}}+\\cdots \\right).}\n\nTaking \\log_2 the Stirling’s approximation becomes \n\\log_2(n!)=n\\log_2(n)-n\\log_2(e)+\\frac{1}{2}\\log_2(2\\pi n)+O\\left(\\frac{1}{n}\\right)\\ ,\n where the O-notation means that for all large values of n, the difference between \\log_2(n!) and n\\log_2(n)-n\\log_2(e)+\\frac{1}{2}\\log_2(2\\pi n) will be at most proportional to \\frac{1}{n}."
  },
  {
    "objectID": "theory_bits/induction.html",
    "href": "theory_bits/induction.html",
    "title": "Induction",
    "section": "",
    "text": "Suppose you have a matemathical sentence P(n) depending on a parameter n which is a natural number. To prove that for every n\\in \\mathbb{N} the sentence P(n) holds, one way is to use Induction on n, that is prove the following two facts\n\n\nBase case\n\nshow that P(0) is true. (Sometimes the base case is P(\\ell) for some natural number \\ell, then, in this case, the induction will prove P(n) to be true for every n\\geq \\ell.)\n\n\n\nInductive Step\n\nshow that for a generic k\\in \\mathbb{N}, if P(k) is true, then also P(k+1) is true.\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\nInduction is always on some parameter (some natural number, the depth of a tree, …).\nUsually proving the Base Case of the induction should be trivial, if this is not the case, perhaps induction is not the right approach.\nInduction is a technique to prove that something is true, but in general not a way to discover that something is true.\n\n\n\n\n\n\n\n\n\nAn example \\sum_{i=0}^n i = n(n+1)/2\n\n\n\n\n\nThere are a lot of different ways to prove that \\sum_{i=0}^n i = n(n+1)/2. For instance a visual “proof” could be based on the following picture:\n\nBy induction, the argument would be as follows.\nLet P(n) be the sentence \\sum_{i=0}^n i = n(n+1)/2. To show that P(n) is true for every n\\in \\mathbb N by Induction on n it suffices to show the Base Case and the Inductive Step.\n\n\nBase Case\n\nP(0) is the sentence \\sum_{i=0}^0 i=0(0+1)/2 which is trivially true, since both sides of the equality are 0.\n\n\n\nInductive Step\n\nassuming P(k) to be true for a generic natural number k, that is \\sum_{i=0}^k i = k(k+1)/2, we need to show that P(k+1) is also true, that is \\sum_{i=0}^{k+1} i = (k+1)(k+2)/2: \n\\begin{align*}\n\\sum_{i=0}^{k+1} i &=\n\\sum_{i=0}^k i + (k+1)\n\\\\\n&\\stackrel{I.H.}{=} \\frac{k(k+1)}{2}+(k+1)\n\\\\\n&=\\frac{k(k+1)+2(k+1)}{2}\n\\\\\n&=\\frac{(k+1)(k+2)}{2}\\ .\n\\end{align*}\n\n\n\n\nIn the equality marked with I.H. we used the Inductive Hypothesis, i.e. the fact we are working under the assumption that P(k) is true.\n\n\n\n\n\n\n\n\n\nWhat can we do if we didn’t remember that \\sum_{i=0}^n i = n(n+1)/2?\n\n\n\n\n\nIf for whatever reason we suspect \\sum_{i=0}^n i to be a polynomial in n of degree 2, say an^2+bn+c then we can substitute values for n and find candidates values for a,b,c.\nFor n=0, \\sum_{i=0}^0 i=0=a\\cdot 0^2+b \\cdot 0 +c, that is c=0.\nFor n=1, \\sum_{i=0}^1 i=1=a\\cdot 1^2+b\\cdot 1 (we are already using c=0).\nFor n=2, \\sum_{i=0}^2 i=3 = a\\cdot 2^2 +b\\cdot 2.\nThat is we have that \n\\begin{matrix}\na+b &= 1\\\\\n4a+2b &= 3\n\\end{matrix}\n which gives the solution a=b=\\frac{1}{2}. That is we suspect that \\sum_{i=0}^n i = n(n+1)/2, but the argument above is not a proof. We need to prove it formally in some way, by induction for instance."
  },
  {
    "objectID": "theory_bits/hash.html",
    "href": "theory_bits/hash.html",
    "title": "Hashing and Hash Tables",
    "section": "",
    "text": "A hash function h is a function that maps a large object \\mathcal D (a genome, a string, a sequence of elements, etc.) into a smaller object (a shorter string, an integer in a small range, etc.). For simplicity, suppose h maps \\mathcal D into the set of natural numbers \\{0,1,\\dots, M-1\\}.\nA hash function must be deterministic and easy to compute.\nA hash function should try to produce different outputs for different inputs. This is not possible to happen for all inputs when M&lt; |\\mathcal D|, for instance. Actually, we should expect to find different elements mapping to the same number as soon as the number of elements in \\mathcal D is \\Omega(\\sqrt M).\n\n\n\n\n\n\nThe birthday paradox\n\n\n\nSuppose that \\mathcal D is a set of people and the hashing function h \\colon \\mathcal D \\to \\{0,1,\\dots,365\\} assigns to each person the day of her/his birthday. The birthday paradox refers to the counterintuitive fact that as soon |\\mathcal D|&gt;23, then with probability at least \\frac{1}{2} there is a collision, i.e. two people in \\mathcal D with the same birthday.\n\n\nWe say that two distinct elements x, y of \\mathcal D collide (under the hash function h) if h(x) = h(y).\nIdeally, a good hash function h should evenly distribute the elements of \\mathcal D into \\{0,1,\\dots, M-1\\}. That is, for every m\\in M, \n\\mathbb E[|\\{x\\in \\mathcal D : h(x)=m\\}|]\\approx \\frac{|\\mathcal D|}{M}\\ .\n In other words, on average we should expect about \\frac{|\\mathcal D|}{M}-many elements of \\mathcal D being mapped to any particular value. The value \\frac{|\\mathcal D|}{M} is called the load factor and it is often denoted with the greek letter \\alpha.\n\n\n\n\n\n\nContruction of hash functions\n\n\n\nDefining a good hash function is not an easy task and it requires a solid background in several branches of Math. This task is very closely related to the definition of good pseudo-random number generators.\nAs a general rule, the keys are first converted to positive integers (reading the binary representation of the key as a number), some mathematical transformation is applied, taking the result modulo M. For various theoretical reasons, it is a good idea that M is a prime number.\n\n\nHash functions are extremely important, for instance in cryptography. Here we only see how to use hash functions to tell whether an element x is in \\mathcal D or not efficiently.\nThis is done using the so-called hash tables with separate chaining. First create M buckets. Then use a hash function h to associate each possible element in \\mathcal D with one bucket. Then, to tell wether an element x is in \\mathcal D or not we can just compute h(x), go to the bucket corresponding to h(x) and look the elements stored there one by one, until we find x or we have seen all elements of the bucket and we didn’t find x.\nTo achive this we can use an array A of linked lists, A[i] will correspond to the ith bucket. All the elements of \\mathcal D mapped by h to i are stored in A[i] using a linked list.\n\n\n\n\n\n\nExample\n\n\n\nGiven \\mathcal D=\\{0, 4, 6, 10, 12, 13, 17, 19, 23, 25, 30\\}, M=13 and h(x)= x\\pmod M, then a hash table with separate chaining looks like the following.\n\n\n\nAssuming a good hash function, i.e. one that spreads the elements approximately evenly, the expected time to look up for an element in a hash table is O(1 + \\frac{|\\mathcal D|}{M})=O(1+\\alpha). So, if \\alpha is a constant this is O(1).\nFor insertions in a hash table with separate chaining, we access the apropriate linked list using the hash function, and scan the list to find out whether the key was already present or not. If present, we modify the associated value; if not, a new node with the pair ⟨key,value⟩ is added to the list. Since the lists contain very few elements each, the simplest and more efficient solution is to add elements to the front.\nThere is no need for double links, sentinels, etc. Sorting the lists or using some other sophisticated data structure instead of linked lists does not report real practical benefits."
  },
  {
    "objectID": "theory_bits/bst.html",
    "href": "theory_bits/bst.html",
    "title": "Binary Search Trees (BST)",
    "section": "",
    "text": "A binary search tree (BST) is a rooted binary tree data structure in which each vertex can have up to two children. Every vertex in the left subtree of a given vertex must carry a value smaller than that of the given vertex, and every vertex in the right subtree must carry a value larger.\nThe time complexity of operations on the binary search tree (insert, delete and search) is linear with respect to the height of the tree. On average, they take O(\\log n) for n nodes. In the worst case, O(n) due to boundless increase of the tree height with arbitrary insertions and deletions.\nAn Adelson-Velskii Landis (AVL) tree is a self-balancing BST that maintains its height within a logarithmic order O(\\log n) relative to the number of vertices n present in the AVL tree."
  },
  {
    "objectID": "theory_bits/avl_trees.html",
    "href": "theory_bits/avl_trees.html",
    "title": "Binary Search Trees",
    "section": "",
    "text": "A Binary Search Tree (BST) T is a binary tree where each vertex v has associated a label \\mathsf{KEY}(v) and T is either empty, or T contains at least one element x at its root, and\nThe height of a BST T with n vertices is \\mathsf{height}(T) and it is the length of the longest path from the root of T to a leaf. It always holds that \n\\lceil \\log_2(n+1)\\rceil \\leq \\mathsf{height}(T) \\leq n\\ ,\n where the first inequality is an equality if T is a perfectly balanced tree."
  },
  {
    "objectID": "theory_bits/avl_trees.html#avl-trees",
    "href": "theory_bits/avl_trees.html#avl-trees",
    "title": "Binary Search Trees",
    "section": "AVL Trees",
    "text": "AVL Trees\nThe main drawback of BSTs is that they can be, or become, strongly unbalanced. The AVL trees were the first-ever self-balancing binary search trees. They were introduced in 1962 by Adelson-Velskii and Landis (hence the acronim AVL). AVL trees are still commonly used in applications like databases and file systems where read and write operations need to be fast and efficient.\nAn AVL tree is a binary search tree that is either empty or\n\nits left and right subtrees, say L and R respectively are both AVL trees, and\nthe height of L and R differs by one at most: \n|\\mathsf{height}(R)−\\mathsf{height}(L)|\\leq 1\\ .\n\n\nThe difference of the two subtree heights indicates the node’s balance factor; by convention, we subtract the right subtree’s height from the left’s. Let \\mathsf{bal}(x) be the difference between the height of the right and left subtrees of an arbitrary vertex x, then, by construction, in a AVL tree we must have \\mathsf{bal}(x) \\in\\{−1,0,+1\\}. Therefore, any node v in an AVL tree can only be of three types:\n\nneutral: the heights of the subtrees are equal,\nleft-heavy: the left subtree has a greater height, or\nright-heavy: the right subtree is taller.\n\nFor instance, the following BST is not an AVL, because the balance factors are not in \\{−1,0,+1\\}.\n\nd3 = require(\"d3-selection@1.4\", \"d3-transition@1.3\", \"d3-ease\", \"d3-interpolate\", \"d3-scale-chromatic@1.5\")\newidth = Math.min(width, 640)\ndur = 2000\nroot = d3.schemeCategory10[0]\npivot = d3.schemeCategory10[1]\nsecondary = d3.schemeCategory10[4]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhtml`&lt;figure&gt;&lt;svg width=${ewidth} height=\"400\"&gt;\n    &lt;line class=\"edge\" id=\"e54\" x1=\"${ewidth/2}\" y1=\"50\" x2=\"${ewidth/4}\" y2=\"150\" stroke=\"black\" /&gt;\n    &lt;line class=\"edge\" id=\"e57\" x1=\"${ewidth/2}\" y1=\"50\" x2=\"${3*ewidth/4}\" y2=\"150\" stroke=\"black\" /&gt;\n    &lt;line class=\"edge\" id=\"e42\" x1=\"${ewidth/4}\" y1=\"150\" x2=\"${ewidth/8}\" y2=\"250\" stroke=\"black\" /&gt;\n    &lt;line class=\"edge\" id=\"e76\" x1=\"${3*ewidth/4}\" y1=\"150\" x2=\"${5*ewidth/8}\" y2=\"250\" stroke=\"black\" /&gt;\n    &lt;line class=\"edge\" id=\"e78\" x1=\"${3*ewidth/4}\" y1=\"150\" x2=\"${7*ewidth/8}\" y2=\"250\" stroke=\"black\" /&gt;\n    &lt;line class=\"edge\" id=\"e23\" x1=\"${ewidth/8}\" y1=\"250\" x2=\"${3*ewidth/16}\" y2=\"350\" stroke=\"black\" /&gt;\n\n    &lt;g class=\"node\" id=\"n5\" transform=\"translate(${ewidth/2}, 50)\"&gt;\n      &lt;circle r=\"25\" fill=\"white\" stroke=\"black\"&gt;&lt;/circle&gt;\n      &lt;text fill=\"black\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;5&lt;/text&gt;\n      &lt;text fill=\"#C00\" transform=\"translate(3, 25)\" alignment-baseline=\"hanging\"&gt;-1&lt;/text&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n4\" transform=\"translate(${ewidth/4}, 150)\"&gt;\n      &lt;circle r=\"25\" fill=\"${root}\" stroke=\"black\"&gt;&lt;/circle&gt;\n      &lt;text fill=\"white\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;4&lt;/text&gt;\n      &lt;text fill=\"#C00\" font-weight=\"bold\" transform=\"translate(3, 25)\" alignment-baseline=\"hanging\"&gt;-2&lt;/text&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n7\" transform=\"translate(${3*ewidth/4}, 150)\"&gt;\n      &lt;circle r=\"25\" fill=\"white\" stroke=\"black\"&gt;&lt;/circle&gt;\n      &lt;text fill=\"black\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;7&lt;/text&gt;\n      &lt;text fill=\"#black\" transform=\"translate(3, 25)\" alignment-baseline=\"hanging\"&gt;+0&lt;/text&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n2\" transform=\"translate(${ewidth/8}, 250)\"&gt;\n      &lt;circle r=\"25\" fill=\"white\" stroke=\"black\"&gt;&lt;/circle&gt;\n      &lt;text fill=\"black\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;2&lt;/text&gt;\n      &lt;text fill=\"#090\" transform=\"translate(15, 20)\" alignment-baseline=\"hanging\"&gt;+1&lt;/text&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n6\" transform=\"translate(${5*ewidth/8}, 250)\"&gt;\n      &lt;circle r=\"25\" fill=\"white\" stroke=\"black\"&gt;&lt;/circle&gt;\n      &lt;text fill=\"black\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;6&lt;/text&gt;\n      &lt;text fill=\"black\" transform=\"translate(3, 25)\" alignment-baseline=\"hanging\"&gt;+0&lt;/text&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n8\" transform=\"translate(${7*ewidth/8}, 250)\"&gt;\n      &lt;circle r=\"25\" fill=\"white\" stroke=\"black\"&gt;&lt;/circle&gt;\n      &lt;text fill=\"black\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;8&lt;/text&gt;\n      &lt;text fill=\"black\" transform=\"translate(3, 25)\" alignment-baseline=\"hanging\"&gt;+0&lt;/text&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n3\" transform=\"translate(${3*ewidth/16}, 350)\"&gt;\n      &lt;circle r=\"25\" fill=\"white\" stroke=\"black\"&gt;&lt;/circle&gt;\n      &lt;text fill=\"black\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;3&lt;/text&gt;\n      &lt;text fill=\"black\" transform=\"translate(3, 25)\" alignment-baseline=\"hanging\"&gt;+0&lt;/text&gt;\n    &lt;/g&gt;\n  &lt;/svg&gt;\n  &lt;figcaption style=\"max-width:640px;text-align:center\"&gt;Balance Factors. &lt;span style=\"color: #C00\"&gt;Red&lt;/span&gt; indicates left-heavy, &lt;span style=\"color: #090\"&gt;green&lt;/span&gt; right-heavy, &lt;span style=\"font-weight:bold\"&gt;bold&lt;/span&gt; indicates where tree is unbalanced.&lt;/figcaption&gt; &lt;/figure&gt;`\n\n\n\n\n\n\nImplementations of AVL trees usually store at each vertex additional information: its height and/or its balance (\\mathsf{bal}(·)) to avoid costly computations.\n\n\n\n\n\n\nLemma\n\n\n\nFor any AVL tree T with n vertices, \\mathsf{height}(T)=\\Theta(\\log n).\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\nSince \\mathsf{height}(T) \\in \\Omega(\\log n) holds for any binary search tree (and therefore, in particular for AVL trees), we need just to show that \\mathsf{height}(T) \\in O(\\log n).\nLet N_h the least number of nodes we need to build an AVL of height h. Clearly, N_0 = 0 and N_1 = 1. The most unbalanced possible AVL with height h&gt;1 can be built by putting a root then a left subtree which is a most unbalanced AVL of height h−1 (using only N_{h−1} nodes), and a right subtree which is a most unblanced AVL of height h−2 (using N_{h−2} nodes). Hence \nN_h = 1 + N_{h−1} + N_{h−2}\\ .\n This sequence looks suspiciously similar to the Fibonacci sequence (F_h)_{h\\in \\mathbb N}, indeed, by induction on h, it is not difficult to show that N_h=F_{h+1}-1. It is well known that F_h=\\Theta(\\varphi^h), where \\varphi=\\frac{1+\\sqrt{5}}{2}. That is, it also holds that \nN_h=\\Theta(\\varphi^h)\\ .\n\\tag{1} Consider now an arbitrary AVL T of n vertices and \\mathsf{height}(T)=h. Then we must have N_h\\leq n (by definition of N_h). Using (Equation 1), in particular we have that for n large enough, there is a constant c such that \nc\\varphi^h\\leq N_h\\leq n\\ .\n Taking \\log of both sides of the inequality we get that h=O(\\log n).\n\n\n\n\nSearch in an AVLInsertion in an AVLDeletion in an AVL\n\n\nThis is done as in any other BST. The thing is that in an AVL, by the previous lemma, the cost of any search for a key in an AVL tree of size n is O(\\log n), even in the worst case.\n\n\nInsertion at first acts as its counterpart for generic BSTs, but then we need to perform extra work to maintain the balance invariant of AVLs.\nIndeed, the insertion done as in a generic BST might invalidate the balance of some nodes, but only of nodes in the path between the root to the inserted vertex. (why?)\nIf the balance condition at some node x is not valid anymore (it can only become +2 or -2) we must do something to fix it and reestablish the invariant. This is done via left and right rotations (or combinations of them).\n\n\n\n\n\n\nThe “magic” of AVL trees\n\n\n\nAfter the insertion of a vertex in an AVL tree, at most 2 rotations are enough to re-establish the balances on every vertex.\n\n\nLet root denote the deepest vertex that is not respecting the balance condition before any rotation, and pivot its child along the path toewards the new vertex added.\nA single rotation is enough to restore the invariant when an unbalanced root has a pivot that is heavy in the same direction, this might be either a right or left rotation, depending if the root was left-hevy or right-heavy.\nBelow, the dotted lines denote the new vertex added.\n\nRight rotation\n\n\n\n\n\n{\n  const view = html`&lt;figure&gt;&lt;svg width=${ewidth} height=\"452\"&gt;\n    &lt;line class=\"edge\" id=\"e12\" x1=\"${ewidth/2}\" y1=\"50\" x2=\"${ewidth/4}\" y2=\"150\" stroke=\"black\" /&gt;\n    &lt;line class=\"edge\" id=\"e13\" x1=\"${ewidth/2}\" y1=\"50\" x2=\"${3*ewidth/4}\" y2=\"150\" stroke=\"black\" /&gt;\n    &lt;line class=\"edge\" id=\"e24\" x1=\"${ewidth/4}\" y1=\"150\" x2=\"${ewidth/8}\" y2=\"250\" stroke=\"black\" /&gt;\n    &lt;line class=\"edge\" id=\"e25\" x1=\"${ewidth/4}\" y1=\"150\" x2=\"${3*ewidth/8}\" y2=\"250\" stroke=\"black\" /&gt;\n\n    &lt;g class=\"node\" id=\"n1\" transform=\"translate(${ewidth/2}, 50)\"&gt;\n      &lt;circle r=\"25\" fill=\"${root}\" stroke=\"black\"&gt;&lt;/circle&gt;\n      &lt;text class=\"value\" fill=\"white\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;root&lt;/text&gt;\n      &lt;text class=\"balance\" fill=\"#C00\" transform=\"translate(3, 25)\" alignment-baseline=\"hanging\" style=\"font-weight:bold\"&gt;-2&lt;/text&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n2\" transform=\"translate(${ewidth/4}, 150)\"&gt;\n      &lt;circle r=\"25\" fill=\"${pivot}\" stroke=\"black\"&gt;&lt;/circle&gt;\n      &lt;text class=\"value\" fill=\"white\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;pivot&lt;/text&gt;\n      &lt;text class=\"balance\" fill=\"#C00\" transform=\"translate(3, 25)\" alignment-baseline=\"hanging\"&gt;-1&lt;/text&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n3\" transform=\"translate(${3*ewidth/4}, 150)\"&gt;\n      &lt;polygon points=\"0, 0 25, 100 -25, 100\" fill=\"white\" stroke=\"black\" /&gt;\n      &lt;text fill=\"black\" y=\"50\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;h&lt;/text&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n4\" transform=\"translate(${ewidth/8}, 250)\"&gt;\n      &lt;polygon points=\"0, 0 25, 100 -25, 100\" fill=\"white\" stroke=\"black\" /&gt;\n      &lt;text fill=\"black\" y=\"50\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;h&lt;/text&gt;\n      &lt;line x1=\"0\" y1=\"100\" x2=\"0\" y2=\"175\" stroke=\"black\" stroke-dasharray=\"4\" /&gt;\n      &lt;circle cy=\"175\" r=\"10\" stroke-dasharray=\"4\" fill=\"white\" stroke=\"black\"&gt;&lt;/circle&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n5\" transform=\"translate(${3*ewidth/8}, 250)\"&gt;\n      &lt;polygon points=\"0, 0 25, 100 -25, 100\" fill=\"white\" stroke=\"black\" /&gt;\n      &lt;text fill=\"black\" y=\"50\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;h&lt;/text&gt;\n    &lt;/g&gt;\n &lt;/svg&gt;\n  &lt;figcaption style=\"max-width:640px;text-align:center\"&gt;Balance Factors before & after a single right rotation&lt;/figcaption&gt;&lt;/figure&gt;`;\n  \n  const tree_view = d3.select(view);\n  var t = d3.transition();\n  \n  tree_view.select(\"#e12\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"x1\", 3*ewidth/4)\n          .attr(\"y1\", 150)\n          .attr(\"x2\", ewidth/2)\n          .attr(\"y2\", 50)\n        .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"x1\", ewidth/2)\n          .attr(\"y1\", 50)\n          .attr(\"x2\", ewidth/4)\n          .attr(\"y2\", 150)\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  tree_view.select(\"#e13\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"x1\", 3*ewidth/4)\n          .attr(\"y1\", 150)\n          .attr(\"x2\", 7*ewidth/8)\n          .attr(\"y2\", 250)\n        .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"x1\", ewidth/2)\n          .attr(\"y1\", 50)\n          .attr(\"x2\", 3*ewidth/4)\n          .attr(\"y2\", 150)\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  tree_view.select(\"#e24\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"x1\", ewidth/2)\n          .attr(\"y1\", 50)\n          .attr(\"x2\", ewidth/4)\n          .attr(\"y2\", 150)\n        .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"x1\", ewidth/4)\n          .attr(\"y1\", 150)\n          .attr(\"x2\", ewidth/8)\n          .attr(\"y2\", 250)\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  tree_view.select(\"#e25\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"x1\", 3*ewidth/4)\n          .attr(\"y1\", 150)\n          .attr(\"x2\", 5*ewidth/8)\n          .attr(\"y2\", 250)\n        .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"x1\", ewidth/4)\n          .attr(\"y1\", 150)\n          .attr(\"x2\", 3*ewidth/8)\n          .attr(\"y2\", 250)\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n\n  \n  tree_view.select(\"#n1\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (3*ewidth/4) + \", 150)\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"transform\", \"translate(\" + (ewidth/2) + \", 50)\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  tree_view.select(\"#n1&gt;.balance\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .textTween(() =&gt; ((t) =&gt; t &lt;= 0.5 ? \"-2\" : \"+0\"))\n          .style(\"fill\", \"black\")\n          .styleTween(\"font-weight\", () =&gt; ((t) =&gt; t &lt;= 0.5 ? \"bold\" :\"normal\"))\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .text(-2)\n          .style(\"fill\", \"#c00\")\n          .style(\"font-weight\", \"bold\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  \n  tree_view.select(\"#n2\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (ewidth/2) + \", 50)\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"transform\", \"translate(\" + (ewidth/4) + \", 150)\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  tree_view.select(\"#n2&gt;.balance\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .textTween(() =&gt; ((t) =&gt; t &lt;= 0.5 ? \"-1\" : \"+0\"))\n          .style(\"fill\", \"black\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .text(\"-1\")\n          .style(\"fill\", \"#c00\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n\n  tree_view.select(\"#n3\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (7*ewidth/8) + \", 250)\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"transform\", \"translate(\" + (3*ewidth/4) + \", 150)\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n\n  tree_view.select(\"#n4\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (ewidth/4) + \", 150)\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"transform\", \"translate(\" + (ewidth/8) + \", 250)\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n\n  tree_view.select(\"#n5\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (5*ewidth/8) + \", 250)\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"transform\", \"translate(\" + (3*ewidth/8) + \", 250)\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  \n  return view;\n}\n\n\n\n\n\n\n\nLeft rotation\n\n\n\n\n\n{\n  const view = html`&lt;figure&gt;&lt;svg width=${ewidth} height=\"452\"&gt;\n    &lt;line class=\"edge\" id=\"e12\" x1=\"${ewidth/2}\" y1=\"50\" x2=\"${3*ewidth/4}\" y2=\"150\" stroke=\"black\" /&gt;\n    &lt;line class=\"edge\" id=\"e13\" x1=\"${ewidth/2}\" y1=\"50\" x2=\"${ewidth/4}\" y2=\"150\" stroke=\"black\" /&gt;\n    &lt;line class=\"edge\" id=\"e24\" x1=\"${3*ewidth/4}\" y1=\"150\" x2=\"${7*ewidth/8}\" y2=\"250\" stroke=\"black\" /&gt;\n    &lt;line class=\"edge\" id=\"e25\" x1=\"${3*ewidth/4}\" y1=\"150\" x2=\"${5*ewidth/8}\" y2=\"250\" stroke=\"black\" /&gt;\n\n    &lt;g class=\"node\" id=\"n1\" transform=\"translate(${ewidth/2}, 50)\"&gt;\n      &lt;circle r=\"25\" fill=\"${root}\" stroke=\"black\"&gt;&lt;/circle&gt;\n      &lt;text class=\"value\" fill=\"white\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;root&lt;/text&gt;\n      &lt;text class=\"balance\" fill=\"#090\" transform=\"translate(3, 25)\" alignment-baseline=\"hanging\" style=\"font-weight:bold\"&gt;+2&lt;/text&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n2\" transform=\"translate(${3*ewidth/4}, 150)\"&gt;\n      &lt;circle r=\"25\" fill=\"${pivot}\" stroke=\"black\"&gt;&lt;/circle&gt;\n      &lt;text class=\"value\" fill=\"white\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;pivot&lt;/text&gt;\n      &lt;text class=\"balance\" fill=\"#090\" transform=\"translate(3, 25)\" alignment-baseline=\"hanging\"&gt;+1&lt;/text&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n3\" transform=\"translate(${ewidth/4}, 150)\"&gt;\n      &lt;polygon points=\"0, 0 25, 100 -25, 100\" fill=\"white\" stroke=\"black\" /&gt;\n      &lt;text fill=\"black\" y=\"50\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;h&lt;/text&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n4\" transform=\"translate(${7*ewidth/8}, 250)\"&gt;\n      &lt;polygon points=\"0, 0 25, 100 -25, 100\" fill=\"white\" stroke=\"black\" /&gt;\n      &lt;text fill=\"black\" y=\"50\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;h&lt;/text&gt;\n      &lt;line x1=\"0\" y1=\"100\" x2=\"0\" y2=\"175\" stroke=\"black\" stroke-dasharray=\"4\" /&gt;\n      &lt;circle cy=\"175\" r=\"10\" stroke-dasharray=\"4\" fill=\"white\" stroke=\"black\"&gt;&lt;/circle&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n5\" transform=\"translate(${5*ewidth/8}, 250)\"&gt;\n      &lt;polygon points=\"0, 0 25, 100 -25, 100\" fill=\"white\" stroke=\"black\" /&gt;\n      &lt;text fill=\"black\" y=\"50\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;h&lt;/text&gt;\n    &lt;/g&gt;\n &lt;/svg&gt;\n  &lt;figcaption style=\"max-width:640px;text-align:center\"&gt;Balance Factors before & after a single left rotation&lt;/figcaption&gt;&lt;/figure&gt;`;\n  \n  const tree_view = d3.select(view);\n  var t = d3.transition();\n  \n  tree_view.select(\"#e12\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"x1\", ewidth/4)\n          .attr(\"y1\", 150)\n          .attr(\"x2\", ewidth/2)\n          .attr(\"y2\", 50)\n        .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"x1\", ewidth/2)\n          .attr(\"y1\", 50)\n          .attr(\"x2\", 3*ewidth/4)\n          .attr(\"y2\", 150)\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  tree_view.select(\"#e13\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"x1\", ewidth/4)\n          .attr(\"y1\", 150)\n          .attr(\"x2\", ewidth/8)\n          .attr(\"y2\", 250)\n        .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"x1\", ewidth/2)\n          .attr(\"y1\", 50)\n          .attr(\"x2\", ewidth/4)\n          .attr(\"y2\", 150)\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  tree_view.select(\"#e24\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"x1\", ewidth/2)\n          .attr(\"y1\", 50)\n          .attr(\"x2\", 3*ewidth/4)\n          .attr(\"y2\", 150)\n        .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"x1\", 3*ewidth/4)\n          .attr(\"y1\", 150)\n          .attr(\"x2\", 7*ewidth/8)\n          .attr(\"y2\", 250)\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  tree_view.select(\"#e25\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"x1\", ewidth/4)\n          .attr(\"y1\", 150)\n          .attr(\"x2\", 3*ewidth/8)\n          .attr(\"y2\", 250)\n        .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"x1\", 3*ewidth/4)\n          .attr(\"y1\", 150)\n          .attr(\"x2\", 5*ewidth/8)\n          .attr(\"y2\", 250)\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n\n  \n  tree_view.select(\"#n1\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (ewidth/4) + \", 150)\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"transform\", \"translate(\" + (ewidth/2) + \", 50)\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  tree_view.select(\"#n1&gt;.balance\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .textTween(() =&gt; ((t) =&gt; t &lt;= 0.5 ? \"+2\" : \"+0\"))\n          .style(\"fill\", \"black\")\n          .styleTween(\"font-weight\", () =&gt; ((t) =&gt; t &lt;= 0.5 ? \"bold\" :\"normal\"))\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .text(\"+2\")\n          .style(\"fill\", \"#090\")\n          .style(\"font-weight\", \"bold\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  \n  tree_view.select(\"#n2\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (ewidth/2) + \", 50)\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"transform\", \"translate(\" + (3*ewidth/4) + \", 150)\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  tree_view.select(\"#n2&gt;.balance\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .textTween(() =&gt; ((t) =&gt; t &lt;= 0.5 ? \"+1\" : \"+0\"))\n          .style(\"fill\", \"black\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .text(\"+1\")\n          .style(\"fill\", \"#090\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n\n  tree_view.select(\"#n3\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + ( ewidth/8) + \", 250)\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"transform\", \"translate(\" + (ewidth/4) + \", 150)\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n\n  tree_view.select(\"#n4\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (3*ewidth/4) + \", 150)\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"transform\", \"translate(\" + (7*ewidth/8) + \", 250)\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n\n  tree_view.select(\"#n5\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (3*ewidth/8) + \", 250)\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"transform\", \"translate(\" + (5*ewidth/8) + \", 250)\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  \n  return view;\n}\n\n\n\n\n\n\nA double rotation occurs when an unbalanced root has a pivot that is heavy in the opposite direction. In this case, if the root was left-heavy and the pivot right-heavy, the invariant can be restored by a doing a left and then a right rotation. The case when the root was right-heavy and the pivot left-heavy is symmetric, first it has to be done a right-rotation and then a left-rotation.\n\nLeft-right rotation\n\n\n\n\n\n{\n  const view = html`&lt;figure&gt;&lt;svg width=${ewidth} height=\"552\"&gt;\n\n    &lt;line class=\"edge\" id=\"e12\" x1=\"${ewidth/2}\" y1=\"50\" x2=\"${ewidth/4}\" y2=\"150\" stroke=\"black\" /&gt;\n    &lt;line class=\"edge\" id=\"e13\" x1=\"${ewidth/2}\" y1=\"50\" x2=\"${3*ewidth/4}\" y2=\"150\" stroke=\"black\" /&gt;\n    &lt;line class=\"edge\" id=\"e24\" x1=\"${ewidth/4}\" y1=\"150\" x2=\"${ewidth/8}\" y2=\"250\" stroke=\"black\" /&gt;\n    &lt;line class=\"edge\" id=\"e25\" x1=\"${ewidth/4}\" y1=\"150\" x2=\"${3*ewidth/8}\" y2=\"250\" stroke=\"black\" /&gt;\n    &lt;line class=\"edge\" id=\"e510\" x1=\"${3*ewidth/8}\" y1=\"250\" x2=\"${5*ewidth/16}\" y2=\"350\" stroke=\"black\" /&gt;\n    &lt;line class=\"edge\" id=\"e511\" x1=\"${3*ewidth/8}\" y1=\"250\" x2=\"${7*ewidth/16}\" y2=\"350\" stroke=\"black\" /&gt;\n\n    &lt;g class=\"node\" id=\"n1\" transform=\"translate(${ewidth/2}, 50)\"&gt;\n      &lt;circle r=\"25\" fill=\"${root}\" stroke=\"black\"&gt;&lt;/circle&gt;\n      &lt;text class=\"value\" fill=\"white\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;root&lt;/text&gt;\n      &lt;text class=\"balance\" fill=\"#C00\" transform=\"translate(3, 25)\" alignment-baseline=\"hanging\" style=\"font-weight:bold\"&gt;-2&lt;/text&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n2\" transform=\"translate(${ewidth/4}, 150)\"&gt;\n      &lt;circle r=\"25\" fill=\"${pivot}\" stroke=\"black\"&gt;&lt;/circle&gt;\n      &lt;text class=\"value\" fill=\"white\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;pivot&lt;/text&gt;\n      &lt;text class=\"balance\" fill=\"#090\" transform=\"translate(3, 25)\" alignment-baseline=\"hanging\"&gt;+1&lt;/text&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n3\" transform=\"translate(${3*ewidth/4}, 150)\"&gt;\n      &lt;polygon points=\"0, 0 25, 200 -25, 200\" fill=\"white\" stroke=\"black\" /&gt;\n      &lt;text fill=\"black\" y=\"125\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;h+1&lt;/text&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n4\" transform=\"translate(${ewidth/8}, 250)\"&gt;\n      &lt;polygon points=\"0, 0 25, 200 -25, 200\" fill=\"white\" stroke=\"black\" /&gt;\n      &lt;text fill=\"black\" y=\"125\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;h+1&lt;/text&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n5\" transform=\"translate(${3*ewidth/8}, 250)\"&gt;\n      &lt;circle r=\"25\" fill=\"${secondary}\" stroke=\"black\"&gt;&lt;/circle&gt;\n      &lt;text class=\"value\" fill=\"white\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;sec&lt;/text&gt;\n      &lt;text class=\"balance\" fill=\"#C00\" transform=\"translate(15, 20)\" alignment-baseline=\"hanging\"&gt;-1&lt;/text&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n10\" transform=\"translate(${5*ewidth/16}, 350)\"&gt;\n      &lt;polygon points=\"0, 0 25, 100 -25, 100\" fill=\"white\" stroke=\"black\" /&gt;\n      &lt;text fill=\"black\" y=\"50\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;h&lt;/text&gt;\n      &lt;line x1=\"0\" y1=\"100\" x2=\"0\" y2=\"175\" stroke=\"black\" stroke-dasharray=\"4\" /&gt;\n      &lt;circle cy=\"175\" r=\"10\" stroke-dasharray=\"4\" fill=\"white\" stroke=\"black\"&gt;&lt;/circle&gt;\n    &lt;/g&gt;\n    &lt;g class=\"node\" id=\"n11\" transform=\"translate(${7*ewidth/16}, 350)\"&gt;\n      &lt;polygon points=\"0, 0 25, 100 -25, 100\" fill=\"white\" stroke=\"black\" /&gt;\n      &lt;text fill=\"black\" y=\"50\" text-anchor=\"middle\" alignment-baseline=\"central\"&gt;h&lt;/text&gt;\n      &lt;line x1=\"0\" y1=\"100\" x2=\"0\" y2=\"175\" stroke=\"black\" stroke-dasharray=\"4\" visibility=\"hidden\" /&gt;\n      &lt;circle cy=\"175\" r=\"10\" stroke-dasharray=\"4\" fill=\"white\" stroke=\"black\" visibility=\"hidden\" &gt;&lt;/circle&gt;\n    &lt;/g&gt;\n &lt;/svg&gt;\n  &lt;figcaption style=\"max-width:640px;text-align:center\"&gt;Balance Factors before & after a left-right double rotation&lt;/figcaption&gt;&lt;/figure&gt;`;\n  \n  const tree_view = d3.select(view);\n  var t = d3.transition();\n    \n  tree_view.select(\"#e12\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n        .transition()\n          .duration(dur)\n          .attr(\"x1\", 3*ewidth/4)\n          .attr(\"y1\", 150)\n          .attr(\"x2\", ewidth/2)\n          .attr(\"y2\", 50)\n        .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"x1\", ewidth/2)\n          .attr(\"y1\", 50)\n          .attr(\"x2\", ewidth/4) \n          .attr(\"y2\", 150)\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  tree_view.select(\"#e13\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n        .transition()\n          .duration(dur)\n          .attr(\"x1\", 3*ewidth/4)\n          .attr(\"y1\", 150)\n          .attr(\"x2\", 7*ewidth/8)\n          .attr(\"y2\", 250)\n        .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"x1\", ewidth/2)\n          .attr(\"y1\", 50)\n          .attr(\"x2\", 3*ewidth/4)\n          .attr(\"y2\", 150)\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  tree_view.select(\"#e24\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"x1\", ewidth/8)\n          .attr(\"y1\", 250)\n          .attr(\"x2\", ewidth/16)\n          .attr(\"y2\", 350)\n        .transition()\n          .duration(dur)\n          .attr(\"x1\", ewidth/4)\n          .attr(\"y1\", 150)\n          .attr(\"x2\", ewidth/8)\n          .attr(\"y2\", 250)\n        .transition()\n          .delay(dur)\n          .duration(0)\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  tree_view.select(\"#e25\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"x1\", ewidth/8)\n          .attr(\"y1\", 250)\n          .attr(\"x2\", ewidth/4)\n          .attr(\"y2\", 150)\n        .transition()\n          .duration(dur)\n          .attr(\"x1\", ewidth/4)\n          .attr(\"y1\", 150)\n          .attr(\"x2\", ewidth/2)\n          .attr(\"y2\", 50)\n        .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"x1\", ewidth/4)\n          .attr(\"y1\", 150)\n          .attr(\"x2\", 3*ewidth/8)\n          .attr(\"y2\", 250)\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  tree_view.select(\"#e510\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"x1\", ewidth/8)\n          .attr(\"y1\", 250)\n          .attr(\"x2\", 3*ewidth/16)\n          .attr(\"y2\", 350)\n        .transition()\n          .duration(dur)\n          .attr(\"x1\", ewidth/4)\n          .attr(\"y1\", 150)\n          .attr(\"x2\", 3*ewidth/8)\n          .attr(\"y2\", 250)\n        .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"x1\", 3*ewidth/8)\n          .attr(\"y1\", 250)\n          .attr(\"x2\", 5*ewidth/16)\n          .attr(\"y2\", 350)\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  tree_view.select(\"#e511\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"x1\", ewidth/4)\n          .attr(\"y1\", 150)\n          .attr(\"x2\", 3*ewidth/8)\n          .attr(\"y2\", 250)\n        .transition()\n          .duration(dur)\n          .attr(\"x1\", 3*ewidth/4)\n          .attr(\"y1\", 150)\n          .attr(\"x2\", 5*ewidth/8)\n          .attr(\"y2\", 250)\n        .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"x1\", 3*ewidth/8)\n          .attr(\"y1\", 250)\n          .attr(\"x2\", 7*ewidth/16)\n          .attr(\"y2\", 350)\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n\n  \n  tree_view.select(\"#n1\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n         .transition()\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (3*ewidth/4) + \", 150)\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"transform\", \"translate(\" + (ewidth/2) + \", 50)\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  tree_view.select(\"#n1&gt;.balance\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n         .transition()\n          .duration(dur)\n          .textTween(() =&gt; ((t) =&gt; t &lt;= 0.5 ? \"-2\" : \"+1\"))\n          .style(\"fill\", \"#090\")\n          .styleTween(\"font-weight\", () =&gt; ((t) =&gt; t &lt;= 0.5 ? \"bold\" :\"normal\"))\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .text(-2)\n          .style(\"fill\", \"#c00\")\n          .style(\"font-weight\", \"bold\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  \n  tree_view.select(\"#n2\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (ewidth/8) + \", 250)\")\n         .transition()\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (ewidth/4) + \", 150)\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  tree_view.select(\"#n2&gt;.balance\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .textTween(() =&gt; ((t) =&gt; t &lt;= 0.5 ? \"+1\" : \"+0\"))\n          .style(\"fill\", \"black\")\n          .attr(\"transform\", \"translate(15,20)\")\n         .transition()\n          .duration(dur)\n          .attr(\"transform\", \"translate(3,25)\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .text(\"+1\")\n          .style(\"fill\", \"#090\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n\n  tree_view.select(\"#n3\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n         .transition()\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (7*ewidth/8) + \", 250)\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"transform\", \"translate(\" + (3*ewidth/4) + \", 150)\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n\n  tree_view.select(\"#n4\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (ewidth/16) + \", 350)\")\n         .transition()\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (ewidth/8) + \", 250)\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n\n  tree_view.select(\"#n5\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (ewidth/4) + \", 150)\")\n         .transition()\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (ewidth/2) + \", 50)\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"transform\", \"translate(\" + (3*ewidth/8) + \", 250)\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n  });\n  tree_view.select(\"#n5&gt;.balance\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"transform\", \"translate(3, 25)\")\n          .textTween(() =&gt; ((t) =&gt; t &lt;= 0.5 ? \"-1\" : \"-2\"))\n          .styleTween(\"font-weight\", () =&gt; ((t) =&gt; t &lt;= 0.5 ? \"normal\" :\"bold\"))\n        .transition()\n          .duration(dur)\n          .textTween(() =&gt; ((t) =&gt; t &lt;= 0.5 ? \"-2\" : \"+0\"))\n          .style(\"fill\", \"black\")\n          .styleTween(\"font-weight\", () =&gt; ((t) =&gt; t &lt;= 0.5 ? \"bold\" :\"normal\"))\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .text(-1)\n          .style(\"fill\", \"#c00\")\n          .style(\"font-weight\", \"normal\")\n          .attr(\"transform\", \"translate(15, 20)\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n    });\n\n    tree_view.select(\"#n10\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (3*ewidth/16) + \", 350)\")\n         .transition()\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (3*ewidth/8) + \", 250)\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"transform\", \"translate(\" + (5*ewidth/16) + \", 350)\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n    });\n\n    tree_view.select(\"#n11\").transition(t)\n    .delay(1000)\n    .on(\"start\", function repeat() {\n      d3.active(this)\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (3*ewidth/8) + \", 250)\")\n         .transition()\n          .duration(dur)\n          .attr(\"transform\", \"translate(\" + (5*ewidth/8) + \", 250)\")\n         .transition()\n          .delay(dur)\n          .duration(0)\n          .attr(\"transform\", \"translate(\" + (7*ewidth/16) + \", 350)\")\n        .transition()\n          .delay(dur)\n          .on(\"start\", repeat);\n     });\n\n  return view;\n}\n\n\n\n\n\n\n\nLeft-right rotation\n\nanalogous to the case above, just symmetric.\n\n\nCredits: the animations of the all the rotations are from this blog-post on understanding AVL rotations.\n\n\nSee the theory slides of EDA."
  },
  {
    "objectID": "theory_bits/STL/index.html",
    "href": "theory_bits/STL/index.html",
    "title": "The C++ Standard Template Library1",
    "section": "",
    "text": "The C++ Standard Template Library (STL) is a collection of templates for several containers (vector, pair, stack, queue, set, etc) that there is no need to re-implement. In this page we will give a short description of some of the templates and methods. For more information see cppreference.com.\nTo use the STL containers and methods when compiling with `g++ it is necessary to use the flag -std=c++11.\nThe rationale behind the STL is to have an interface as uniform as possible. For instance, it is possible to give initialization lists to STL containers.\nIn the same spirit of uniformity, there are several common methods. For instance the followings.\nMoreover, since the C++11 standard, if the compiler can infer the type of a variable, instead of writing explicitly its type, it is possible to use auto.\nAlso for loops got an alternative (less error prone) syntax when used in collections such as set&lt;T&gt;."
  },
  {
    "objectID": "theory_bits/STL/index.html#pairt1t2",
    "href": "theory_bits/STL/index.html#pairt1t2",
    "title": "The C++ Standard Template Library1",
    "section": "pair<T1,T2>",
    "text": "pair&lt;T1,T2&gt;\npair&lt;T1,T2&gt; is equivalent to\nstruct pair {\n  T1 first;\n  T2 second;\n};\nA pair allows to form a pair with the first value of type T1 and the second value of type T2. It is possible to access the values with first and second.\nThe pairs are useful since some functions of the STL need to return 2 values. Moreover they have automatically defined some operators, for instance:\n\nequality == (component-wise)\ncomparison &lt; (lexicographically)2\n\n\n\n\n\n\n\nExample of usage\n\n\n\n#include&lt;iostream&gt;\n\nusing namespace std;\n\nint main(){\n  pair&lt;double, char&gt; a(2.5, 'A');\n  pair&lt;double, char&gt; b;\n  b.first = 3.5;\n  b.second = 'B';\n  cout &lt;&lt; (a == make_pair(2.5, 'A')) &lt;&lt; endl;  // --&gt; 1\n  cout &lt;&lt; (a &lt; b) &lt;&lt; endl;                     // --&gt; 1\n}"
  },
  {
    "objectID": "theory_bits/STL/index.html#priority_queuet",
    "href": "theory_bits/STL/index.html#priority_queuet",
    "title": "The C++ Standard Template Library1",
    "section": "priority_queue<T>",
    "text": "priority_queue&lt;T&gt;\nA priority_queue&lt;T&gt; is a priority queue of elements of T. By default, the largest element is the one on top, i.e. the first to come out.\n\nSome methods for priority_queue&lt;T&gt;. For the full list see cppreference.com.\n\n\n\n\n\n\n\nMethod\n\nCost\n\n\n\n\nvoid push(const T& x)\nadds x to the queue\n\\Theta(\\log n)\n\n\nvoid pop()\nremoves the largest element\n\\Theta(\\log n)\n\n\nconst T& top() const\nreturns the top of the queue\n\\Theta(1)\n\n\n\nTo use priority_queue&lt;T&gt; it is necessary #include &lt;queue&gt;.\n\n\n\n\n\n\nExample (Heapsort)\n\n\n\nRead a sequence of integers and write it in decreasing order.\n#include &lt;queue&gt;\n#include&lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n  priority_queue&lt;int&gt; pq;\n  int x;\n  while (cin &gt;&gt; x) pq.push(x);\n  while (not pq.empty()) {\n    cout &lt;&lt; pq.top() &lt;&lt; endl;\n    pq.pop();\n  }\n}"
  },
  {
    "objectID": "theory_bits/STL/index.html#sett",
    "href": "theory_bits/STL/index.html#sett",
    "title": "The C++ Standard Template Library1",
    "section": "set<T>",
    "text": "set&lt;T&gt;\nA set&lt;T&gt; is a ordered set of elements of type T. By default, the elements are ordered increasingly.3\nTo use set&lt;T&gt; it is necessary #include &lt;set&gt;.\nAn interator set&lt;T&gt;::iterator it is moved forward with ++it and backward --it. To access the element pointed by an iterator it we use *it.\n\nSome methods for set&lt;T&gt;. For the full list see cppreference.com.\n\n\n\n\n\n\n\nMethod\n\nCost\n\n\n\n\npair&lt;set&lt;T&gt;::iterator,bool&gt; insert (const T& x);\nadds x to the set. If x was not in the set it returns an iterator to the place of x and true. Otherwise, an iterator to x in the set and false\n\\Theta(\\log n)\n\n\nset&lt;T&gt;::iterator begin()\nreturns an iterator to the first element of the set\n\\Theta(1)\n\n\nset&lt;T&gt;::iterator end()\nreturns an iterator after the last element of the set\n\\Theta(1)\n\n\nset&lt;T&gt;::iterator find(const T& x) const\nlooks for x in the set. If x was in the set it returns an iterator pointing to it. Otherwise it returns end()\n\\Theta(\\log n)\n\n\nvoid erase(iterator it)\ndeletes the element pointed by it\n\\Theta(1) (amortized)\n\n\nint erase(const T& x)\nif x is in the set, deletes it and returns 1. Otherwise, returns 0\n\\Theta(\\log n)\n\n\n\n\n\n\n\n\n\nExample\n\n\n\nRead two sequences of integers (ending wth 0) and write their intersection.\n#include &lt;set&gt;\n\nint main() {\n  set&lt;int&gt; s1, s2;\n  int x;\n  while (cin &gt;&gt; x and x != 0) s1.insert(x);\n  while (cin &gt;&gt; x and x != 0) s2.insert(x);\n\n  for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); ++it)\n    if (s2.find(*it) != s2.end())\n      cout &lt;&lt; *it &lt;&lt; endl;\n}"
  },
  {
    "objectID": "theory_bits/STL/index.html#mapkv",
    "href": "theory_bits/STL/index.html#mapkv",
    "title": "The C++ Standard Template Library1",
    "section": "map<K,V>",
    "text": "map&lt;K,V&gt;\nA map&lt;K,V&gt; is a dictionary with keys K and values V. It behaves similarly yo a set of pairs (key,value), that is keys are never repeated. By default, the keys are ordered increasingly.4\nTo use map&lt;K,V&gt; it is necessary #include &lt;map&gt;.\nAn iterator map&lt;K,V&gt;::iterator it is moved forward using ++it and backward --it. To access the pair pointed by it we use *it. To access the key pointed by it we can use (*it).first or it-&gt;first. To access the value pointd by it we can use (*it).second or it-&gt;second.\n\nSome methods for map&lt;K,V&gt;. For the full list see cppreference.com.\n\n\n\n\n\n\n\nMethod\n\nCost\n\n\n\n\npair&lt;map&lt;K,V&gt;::iterator,bool&gt; insert (const pair&lt;K,V&gt;& p)\nadd the pair p. If there was a pair with that key, it returns an iterator to the exsiting pair and false. Otherwise, adds the pair p to the map and returns an iterator to it and true\n\\Theta(\\log n)\n\n\nmap&lt;K,V&gt;::iterator begin()\nreturns an iterator to the pair with the first key in the ordering (by default the smallest key)\n\\Theta(1)\n\n\nmap&lt;K,V&gt;::iterator end()\nreturns an interator after the pair with the last key in the ordering (by default the largest key)\n\\Theta(1)\n\n\nmap&lt;K,V&gt;::iterator find(const K& k) const\nlooks for the pair with key k in the map. If it finds it, returns an iterator pointing to it. Otherwise returns end()\n\\Theta(\\log n)\n\n\nvoid erase(map&lt;K,V&gt;::iterator it)\ndeletes the pair pointed by it\n\\Theta(1) (amortized)\n\n\nint erase (const K& k)\nif there is an element with key k, deletes it and returns 1. Otherwise, returns 0\n\\Theta(\\log n)\n\n\n\n\n\n\n\n\n\nExample\n\n\n\nThe following code\n#include &lt;map&gt;\n\nusing namespace std;\n\nusing P = pair&lt;char,int&gt;;\nusing M = map&lt;char,int&gt;;\n\nint main(){\n\n  M m;\n\n  m.insert( P('a', 10) );\n  m.insert( make_pair('c', 30) );\n  m['d'] = 40;\n  /* \n  The operator [] admits a key k as an argument.\n  If there is a pair with the key k, it returns a reference to the value of the pair (k,value) in the map.\n  Otherwise, it inserts a pair (k,value) and uses the constructor by default of the associated type (e.g. for the type int assigns 0). Then, it returns a reference to the second element of the pair (the value).\n  */\n\n  m.erase('c');\n\n  for (M::iterator it = m.begin(); it != m.end(); ++it) \n    cout &lt;&lt; it-&gt;first &lt;&lt; \" \" &lt;&lt; it-&gt;second &lt;&lt; endl;\n}\nhas output\na 10\nd 40"
  },
  {
    "objectID": "theory_bits/STL/index.html#unordered_sett",
    "href": "theory_bits/STL/index.html#unordered_sett",
    "title": "The C++ Standard Template Library1",
    "section": "unordered_set<T>",
    "text": "unordered_set&lt;T&gt;\nAn unordered_set&lt;T&gt; is like a set but it does not guarantees an order on the elements.\ninsert, find, erase work in time \\Theta(n) (worst case), but in time \\Theta(1) on average.5\n\n\n\n\n\n\nExample\n\n\n\n#include &lt;iostream&gt;\n#include &lt;unordered_set&gt;\n\nusing namespace std;\n\nint main() {\n\n  unordered_set&lt;int&gt; s1, s2;\n  int x;\n\n  while (cin &gt;&gt; x and x != 0)\n    s1.insert(x);\n  \n  while (cin &gt;&gt; x and x != 0)\n    s2.insert(x);\n\n  for (auto y : s1) \n    if (s2.find(y) != s2.end()) \n      cout &lt;&lt; y &lt;&lt; endl;\n}"
  },
  {
    "objectID": "theory_bits/STL/index.html#unordered_mapkv",
    "href": "theory_bits/STL/index.html#unordered_mapkv",
    "title": "The C++ Standard Template Library1",
    "section": "unordered_map<K,V>",
    "text": "unordered_map&lt;K,V&gt;\nAn unordered_map&lt;K,V&gt; is like a map but it does not guarantee an order on the pairs.\ninsert, find, erase work in time \\Theta(n) (worst case), but in time \\Theta(1) on average.6\n\n\n\n\n\n\nExample\n\n\n\n#include &lt;unordered_map&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n  unordered_map&lt;string, int&gt; m;\n  string x;\n  while (cin &gt;&gt; x) ++m[x];\n  for(auto p : m)\n    cout &lt;&lt; p.first &lt;&lt; \" \" &lt;&lt; p.second &lt;&lt; endl;\n}"
  },
  {
    "objectID": "theory_bits/STL/index.html#footnotes",
    "href": "theory_bits/STL/index.html#footnotes",
    "title": "The C++ Standard Template Library1",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe content of this page is mostly based on STL and Algorithms in C++.↩︎\nThat is a&lt;b is true when either a.first &lt; b.first or when a.first == b.first and a.second &lt; b.second.↩︎\nInternally, set&lt;T&gt; is implemented with a balanced binary search tree.↩︎\nInternally, map&lt;K,V&gt; is implemented with balanced binary search trees.↩︎\nInternally, unordered_set&lt;T&gt; is implemented with a Hash table.↩︎\nInternally, unordered_map&lt;K,V&gt; is implemented with a Hash table.↩︎"
  },
  {
    "objectID": "theory/T8.html",
    "href": "theory/T8.html",
    "title": "EDA",
    "section": "",
    "text": "Warning\n\n\n\nThis page is a draft. It will be updated closer to the class.",
    "crumbs": [
      "*Graphs*",
      "T8"
    ]
  },
  {
    "objectID": "theory/T6.html",
    "href": "theory/T6.html",
    "title": "EDA",
    "section": "",
    "text": "Warning\n\n\n\nThis page is a draft. It will be updated closer to the class.",
    "crumbs": [
      "*Priority Queues*",
      "T6"
    ]
  },
  {
    "objectID": "theory/T4.html",
    "href": "theory/T4.html",
    "title": "EDA",
    "section": "",
    "text": "Warning\n\n\n\nThis page is a draft. It will be updated closer to the class.",
    "crumbs": [
      "*Divide and Conquer*",
      "T4"
    ]
  },
  {
    "objectID": "theory/T2.html",
    "href": "theory/T2.html",
    "title": "Analysis of Algorithms",
    "section": "",
    "text": "View slides in full screen\nSome additional material related to this class is the following:",
    "crumbs": [
      "*Analysis of Algorithms*",
      "T2"
    ]
  },
  {
    "objectID": "theory/T2.html#exercises",
    "href": "theory/T2.html#exercises",
    "title": "Analysis of Algorithms",
    "section": "Exercises",
    "text": "Exercises\nOnce you have revised the material from this class, you can try to do the problems in the EDA Problem Set, section 1 Analysis of algorithms. In particular Exercises 1.12, 1.13, 1.14 (no (g)) , 1.18, 1.23. Those exercises will be solved in class in the Problem class P2.\nAfter this class and/or the Problem class P2 you should also be able to solve the following past exams exercises from the Collection of Solved Exams:\n\n06/11/2020 Midterm EDA Exam Problem 2.a and 2.b\n15/04/2021 Midterm EDA Exam Problem 1.b and 1.c\n03/11/2022 Midterm EDA Exam Problem 2.a\n02/11/2023 Midterm EDA Exam Problem 2\n07/06/2021 Final EDA Exam Problem 1.c\n\nThe solutions of the above problems are in the same pdf containing their statement.\n\n\n\n\n\n\nImportant\n\n\n\nIf you have doubts while solving the above exercises (after studying the material and the Problem class P2) please write me an email as soon as possible (and/or write an email to your instructor of the problem class P2).",
    "crumbs": [
      "*Analysis of Algorithms*",
      "T2"
    ]
  },
  {
    "objectID": "theory/T12.html",
    "href": "theory/T12.html",
    "title": "EDA",
    "section": "",
    "text": "Warning\n\n\n\nThis page is a draft. It will be updated closer to the class.",
    "crumbs": [
      "*Notions of Intractability*",
      "T12"
    ]
  },
  {
    "objectID": "theory/T10.html",
    "href": "theory/T10.html",
    "title": "EDA",
    "section": "",
    "text": "Warning\n\n\n\nThis page is a draft. It will be updated closer to the class.",
    "crumbs": [
      "*Exhaustive Search and Generation*",
      "T10"
    ]
  },
  {
    "objectID": "self_assessment/index.html",
    "href": "self_assessment/index.html",
    "title": "EDA",
    "section": "",
    "text": "Question\n\n\n\nIf I want to run a single-file program program.cc, do I need to first compile and generate the object program.o with g++ -c program.cc, and then link to produce the executable with g++ program.o?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nOne could do that, but in this case it can all be done in a single line: g++ program.cc.\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nIf I want to use any of the features of the C++ 2011 standard in my program program.cc, how should I compile it with g++?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\ng++ -std=c++11 program.cc\nNote that std stands for standard.\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nHow can I tell g++ to warn me against everything that is found suspicious during compilation?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\ng++ -Wall program.cc\nNote that Wall stands for Warning all. It is wise to always use the -Wall flag.\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nHow can I tell g++ to optimize the generated code?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nFor instance, with\ng++ -O2 program.cc\nnearly all supported optimizations not involving a space-speed tradeoff are performed. Note that O stands for Optimization.\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nI have an executable a.out and want to read data from a file sample.inp rather than from the keyboard, and write the output on a new file sample.out instead of to the screen. How can I do that?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n./a.out &lt; sample.inp &gt; sample.out\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nHow can I find the differences between two files sample.out and sample.cor?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nFor example:\ndiff sample.out sample.cor\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nIn C++, how can I create a bidimensional matrix matrix of ints with n rows and m columns, all of them initialized to 1?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe standard library of C++ does not have a built-in type “matrix”. A way to create the matrix is by creating a vector of n rows, each of which is a vector of m integers initialized to 1. By using the standard template class vector&lt;T&gt; and the constructor vector&lt;T&gt;(size, init) (which creates a vector of size copies of init):\nvector&lt;int&gt; row(m, 1); \nvector&lt;vector&lt;int&gt;&gt; matrix(n, row);\nEquivalently (and better) in a single line:\nvector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(m, 1));\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nI have to sort a vector v of ints increasingly. Should I write my own sorting procedure?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nNo (unless there is another reason for doing so). Use the sort procedure of the standard C++ library:\n#include &lt;algorithm&gt; \n\n//...\n\nsort(v.begin(), v.end());\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nAnd what if I have to sort decreasingly?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe sort procedure admits a third parameter: the sorting criterion. It is a function or a function object that takes as parameters two objects of the container (in this case, two ints) and returns true when the first argument should come before the second one. For instance, in this case:\n#include &lt;algorithm&gt; \n\nbool before(int a, int b) { return a &gt; b;} \n\n// ...\n\nsort(v.begin(), v.end(), before);\nFunction objects of class greater&lt;int&gt;, available in the standard library, behave essentially the same as the aforementioned function before, and give an elegant solution:\n#include &lt;algorithm&gt; \n\n// ...\n\nsort(v.begin(), v.end(), greater&lt;int&gt;());\nAnother example of function before, now defined over structs:\n// first small surnames, in case of tie big names, in case of tie the younger one \nbool before(const Info& a, const Info& b) {\n  if (a.surname != b.surname) \n    return a.surname &lt; b.surname; \n  if (a.name  != b.name) \n    return a.name &gt; b.name;\nreturn a.age &lt; b.age; \n}\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nLet s be a stack&lt;pair&lt;int,int&gt;. Can the following code be written more compactly? (assuming that aux is not used any more)\npair&lt;int,int&gt; aux; \naux.first = 1; \naux.second = 2;\ns.push(aux);\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nOne can make the compiler generate the adequate temporary object by calling a constructor of pair&lt;int,int&gt;. For example, any of the following would do:\ns.push(pair&lt;int,int&gt;(1, 2)); \ns.push(make pair(1, 2));\ns.push({1, 2}); // This is C++11 \n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nWhen I compile my program program.cc I get the output below. Where is the error?\nuser@machine:$ g++ program.cc\n   program.cc: In function ‘int main()’:\n   program.cc:10:8: error: no match for ‘operator&lt;&lt;’ (operand types are ‘std::ostream\n   {aka std::basic_ostream&lt;char&gt;}’ and ‘std::vector&lt;int&gt;’)\n      cout &lt;&lt; v &lt;&lt; endl;\n           ^\n   In file included from /usr/include/c++/5/iostream:39:0,\n                    from program.cc:1:\n   /usr/include/c++/5/ostream:108:7: note: candidate: std::basic_ostream&lt;_CharT,\n   _Traits&gt;::__ostream_type& std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(std::basic_ostream&lt;_\n   _Traits&gt;::__ostream_type& (*)(std::basic_ostream&lt;_CharT, _Traits&gt;::__ostream_type&))\n   [with _CharT = char; _Traits = std::char_traits&lt;char&gt;; std::basic_ostream&lt;_CharT,\n   _Traits&gt;::__ostream_type = std::basic_ostream&lt;char&gt;]\n          operator&lt;&lt;(__ostream_type& (*__pf)(__ostream_type&))\n          ^\n   /usr/include/c++/5/ostream:108:7: note:   no known conversion for argument\n   1 from ‘std::vector&lt;int&gt;’ to ‘std::basic_ostream&lt;char&gt;::__ostream_type&\n   (*)(std::basic_ostream&lt;char&gt;::__ostream_type&) {aka std::basic_ostream&lt;char&gt;&\n   (*)(std::basic_ostream&lt;char&gt;&)}’\n   /usr/include/c++/5/ostream:117:7: note: candidate: std::basic_ostream&lt;_CharT,\n   _Traits&gt;::__ostream_type& std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(std::basic_ostream&lt;_\n   _Traits&gt;::__ios_type& (*)(std::basic_ostream&lt;_CharT, _Traits&gt;::__ios_type&))\n   [with _CharT = char; _Traits = std::char_traits&lt;char&gt;; std::basic_ostream&lt;_CharT,\n   _Traits&gt;::__ostream_type = std::basic_ostream&lt;char&gt;; std::basic_ostream&lt;_CharT,\n   _Traits&gt;::__ios_type = std::basic_ios&lt;char&gt;]\n          operator&lt;&lt;(__ios_type& (*__pf)(__ios_type&))\n          ^\n   /usr/include/c++/5/ostream:117:7: note:   no known conversion for argument\n   1 from ‘std::vector&lt;int&gt;’ to ‘std::basic_ostream&lt;char&gt;::__ios_type& (*)(std::basic_ostream&lt;cha\n   {aka std::basic_ios&lt;char&gt;& (*)(std::basic_ios&lt;char&gt;&)}’\n   /usr/include/c++/5/ostream:127:7: note: candidate: std::basic_ostream&lt;_CharT,\n   _Traits&gt;::__ostream_type& std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(std::ios_base&\n   (*)(std::ios_base&)) [with _CharT = char; _Traits = std::char_traits&lt;char&gt;;\n   std::basic_ostream&lt;_CharT, _Traits&gt;::__ostream_type = std::basic_ostream&lt;char&gt;]\n          operator&lt;&lt;(ios_base& (*__pf) (ios_base&))\n  ...\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nDo not get overwhelmed by lengthy error reports. Focus on the (very) first lines. Here\nprogram.cc:10:8: error: no match for ‘operator&lt;&lt;’ (operand types are ‘std::ostream\n{aka std::basic_ostream&lt;char&gt;}’ and ‘std::vector&lt;int&gt;’)\n   cout &lt;&lt; v &lt;&lt; endl;\nis telling us that at line 10, column 8, the operator &lt;&lt; is misused."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Structures and Algorithmics",
    "section": "",
    "text": "Welcome to Data Structures and Algorithmics (aka EDA)!\nI’m Ilario Bonacina and if you are a student of the group T40 then I’m one of your instructors for this semester. This is the webpage I’ll use as a support for the EDA theory classes for the group T40.\nAll the announcements will be done through the racó. \n Upcoming (theory) class\n\n\n\n\n\n\n Contacts\n\n\n\n\n\nThe person in charge of the whole course is Albert Oliveras Llunell (email). For administrative questions (or any question on the EDA Game) please ask him directly.\nMy email for this course is ilario.bonacina+EDA@upc.edu. The last possible day to ask questions is 6 days before the partial/final/lab exam.\nThe person in charge of the Problem/Lab groups P41/L41 is Salvator Roura (email). The person in charge of the Problem/Lab groups P42/L42 is Elisabeth Burjons (email). The person in charge of the Lab group L43 is Daniel Benedí (email). You can also email them directly for questions more related to the problems/lab classes.\n\n\n\n\n\n\n\n\n\n Calendar\n\n\n\n\n\nTheory (“T”) classes are on Mondays and Problems/Lab classes (“P”/“L”) are on Wednesdays (unless stated otherwise).\n\n\nWeek 1\nT1 — Analysis of Algorithms\nL1 — The C++ Standard Library\nWeek 2\nT2 — Analysis of Algorithms\nP1 — Analysis of Algorithms\nWeek 3\nT3 — Divide and Conquer\nP2 — Analysis of Algorithms\nWeek 4\nT4 — Divide and Conquer\nP3 — Divide and Conquer\nWeek 5\nT5 — Dictionaries\nL2 — Divide and Conquer\nWeek 6\nT6 — Dictionaries + Priority queues\nP4 — Dictionaries\nWeek 7\nT7 — Graphs\nP5 — Priority queues\nWeek 8\nT8 — Graphs\nPartial Exam (April 3, 18:00 — 20:00)\n\n\n\n“Week” 9\nL3 — Graphs (April 9)\nL4 — Graphs (April 23)\nEDA Game (April 24, see EDA Curs 2024/2025 Q2 on jutge.org for the statement)\nWeek 10\nT9 — Exhaustive search and generation\nP6 — Graphs\nWeek 11\nT10 — Exhaustive search and generation\nL5 — Exhaustive search and generation\nWeek 12\nT11 — Notions of intractability\nCompetència Transversal (May 12, see racó for the statement)\nL6 — Exhaustive search and generation\nWeek 13\nT12 — Notions of intractability\nP7 — Notions of intractability\nWeek 14\nT13 — Notions of intractability\nP8 — Notions of intractability\nWeek 15\nFinal Exam (June 4, 15:00 — 18:00)\nLab Exam (June 13, 08:30 — 11:00)\n\n\n\n\n\n\n\n\n\n\n\n\n Evaluation\n\n\n\n\n\nNPP = written mid-semester exam grade (0 to 10)\nNO = computer-based lab exam grade (0 to 10)\nNF = final exam grade (0 to 10)\nNJ = game grade (0 to 10)\n\n\\begin{align*}\n\\text{GRADE}=\\min\\{10,\\ \\max\\{&22.5\\%NPP + 22.5\\%NF + 45\\%NO + 20\\%NJ,\\\\\n& 45\\%NF + 45\\%NO + 20\\%NJ\\}\\}\n\\end{align*}\n (source: the EDA Official syllabus)",
    "crumbs": [
      "Course Info<br><br>"
    ]
  },
  {
    "objectID": "references/index.html",
    "href": "references/index.html",
    "title": " References",
    "section": "",
    "text": "This page is just a support for the problem/lab classes I’m giving. Please refer to the main webpage of EDA for news, course material, etc and to the official UPC page for the course syllabus.\nIn the EDA Main Page \\to Material Docent you’ll find the following useful material:\n\nAlgorismes en C++\nNormes de Programació (in catalan) This file describes the accepted style of C++ writing.  It is used as a reference for correcting the lab exam.\nEines de Suport a la Programació (in catalan) A list of possibly useful software (source code editors, debuggers, git, …)\n\nRegarding C++ references, the standard ones are\n\n\ncppreference.com\n\nand its offline version C++ reference which is available to consult during the lab exam. Have a look at it to know what is not needed to memorize.\n\n\n  The C++ Programming Language\nBjarne Stroustrup. Addison-Wesley, (4th ed.) 2013"
  },
  {
    "objectID": "theory/T1.html",
    "href": "theory/T1.html",
    "title": "Introduction and Asymptotic Notation",
    "section": "",
    "text": "View slides in full screen\nSome additional material related to this class is the following:",
    "crumbs": [
      "*Analysis of Algorithms*",
      "T1"
    ]
  },
  {
    "objectID": "theory/T1.html#exercises",
    "href": "theory/T1.html#exercises",
    "title": "Introduction and Asymptotic Notation",
    "section": "Exercises",
    "text": "Exercises\nOnce you have revised the material from this class, you can try to do the problems in the EDA Problem Set, section 1 Analysis of algorithms. In particular Exercises 1.1, 1.3, 1.7, 1.8, 1.9. Those exercises will be solved in class in the Problem class P1.\nAfter this class and/or the Problem class P1 you should also be able to solve the following past exams exercises from the Collection of Solved Exams:\n\n06/11/2020 Midterm EDA Exam Problem 1.b\n15/04/2021 Midterm EDA Exam Problem 1.a\n03/11/2022 Midterm EDA Exam Problem 1.b\n02/11/2023 Midterm EDA Exam Problem 1.b\n07/06/2021 Final EDA Exam Problem 1.a\n\nThe solutions of the above problems are in the same pdf containing their statement.\n\n\n\n\n\n\nImportant\n\n\n\nIf you have doubts while solving the above exercises (after studying the material and the Problem class P1) please write me an email as soon as possible (and/or write an email to your instructor of the problem class P1).",
    "crumbs": [
      "*Analysis of Algorithms*",
      "T1"
    ]
  },
  {
    "objectID": "theory/T11.html",
    "href": "theory/T11.html",
    "title": "EDA",
    "section": "",
    "text": "Warning\n\n\n\nThis page is a draft. It will be updated closer to the class.",
    "crumbs": [
      "*Notions of Intractability*",
      "T11"
    ]
  },
  {
    "objectID": "theory/T13.html",
    "href": "theory/T13.html",
    "title": "EDA",
    "section": "",
    "text": "Warning\n\n\n\nThis page is a draft. It will be updated closer to the class.",
    "crumbs": [
      "*Notions of Intractability*",
      "T13"
    ]
  },
  {
    "objectID": "theory/T3.html",
    "href": "theory/T3.html",
    "title": "Divide and Conquer",
    "section": "",
    "text": "View slides in full screen\nSome additional material related to this class is the following:",
    "crumbs": [
      "*Divide and Conquer*",
      "T3"
    ]
  },
  {
    "objectID": "theory/T3.html#exercises",
    "href": "theory/T3.html#exercises",
    "title": "Divide and Conquer",
    "section": "Exercises",
    "text": "Exercises\nOnce you have revised the material from this class, you can try to do the problems from the EDA ProblemSet, section 2 Divide and Conquer.. In particular Exercises 2.9, 2.10, 2.11, 2.12. Those exercises will be solved in class in the Problem class P3.\nAfter this class and/or the Problem class P3 you should also be able to solve the MidTerm EDA Exams from the Collection of Solved Exams where there is some C++ code to complete. As always, the solutions are in the very same pdf.\n\n\n\n\n\n\nImportant\n\n\n\nIf you have doubts while solving the above exercises (after studying the material and the Problem class P3) please write me an email as soon as possible (and/or write an email to your instructor of the problem class P3).",
    "crumbs": [
      "*Divide and Conquer*",
      "T3"
    ]
  },
  {
    "objectID": "theory/T5.html",
    "href": "theory/T5.html",
    "title": "EDA",
    "section": "",
    "text": "Warning\n\n\n\nThis page is a draft. It will be updated closer to the class.",
    "crumbs": [
      "*Dictionaries*",
      "T5"
    ]
  },
  {
    "objectID": "theory/T7.html",
    "href": "theory/T7.html",
    "title": "EDA",
    "section": "",
    "text": "Warning\n\n\n\nThis page is a draft. It will be updated closer to the class.",
    "crumbs": [
      "*Graphs*",
      "T7"
    ]
  },
  {
    "objectID": "theory/T9.html",
    "href": "theory/T9.html",
    "title": "EDA",
    "section": "",
    "text": "Warning\n\n\n\nThis page is a draft. It will be updated closer to the class.",
    "crumbs": [
      "*Exhaustive Search and Generation*",
      "T9"
    ]
  },
  {
    "objectID": "theory_bits/NP.html",
    "href": "theory_bits/NP.html",
    "title": "On NP and related concepts",
    "section": "",
    "text": "Definition 1 (Decision problem) Given a set of inputs I, a decision problem A is a subset of I. (The problem associated with A is the problem of deciding wether a given input x is in A or not.)\nSome important deterministic time complexity classes are the following."
  },
  {
    "objectID": "theory_bits/NP.html#nondeterminism-and-mathsfnp",
    "href": "theory_bits/NP.html#nondeterminism-and-mathsfnp",
    "title": "On NP and related concepts",
    "section": "Nondeterminism and \\mathsf{NP}",
    "text": "Nondeterminism and \\mathsf{NP}\nThe class \\mathsf{NP} (nondeterministic polynomial time) is the set of all problems which can be verified in deterministic polynomial time.\n\nDefinition 3 (\\mathsf{NP}) A decision problem A is in \\mathsf{NP} if and only is there is an integer k\\in \\mathbb N and an algorithm V (called verifier) such that\n\nThe output of V is Boolean (true/false), V takes as input strings of the form (x,y) and runs in polynomial time (w.r.t. |x|+|y|);\nif x\\in A then there is a string c (called certificate) such that |c|\\leq |x|^k and V with input (x,c) returns true;\nif x \\notin A, for every string c with |c|\\leq |x|^k, V on input (x,c) returns false .\n\n\n\n\\mathsf{P} vs \\mathsf{NP} problem\nIt is not too difficult to see that \n\\mathsf{P}\\subseteq \\mathsf{NP}\\subseteq \\mathsf{EXP}\\ .\n\nOn the other hand, again by the Time Hierarchy Theorem, we know that \\mathsf{P}\\neq \\mathsf{EXP}. So either \\mathsf{P}\\neq \\mathsf{NP} or \\mathsf{NP}\\neq \\mathsf{EXP} or both. But, which is the case? With the current knowledge the following scenarios below are perfectly possible:\n\n\\mathsf{P}\\neq \\mathsf{NP} and \\mathsf{NP}\\neq \\mathsf{EXP},\n\\mathsf{P}\\neq \\mathsf{NP} and \\mathsf{NP}= \\mathsf{EXP},\n\\mathsf{P}= \\mathsf{NP} and \\mathsf{NP}\\neq \\mathsf{EXP},\n\nIt is also possible that \\mathsf{P}=\\mathsf{NP} and \\mathsf{P}\\neq \\mathsf{NP} are both perfectly coherent with all the commonly accepted axioms of mathematics…\n\n\n\n\n\n\nWhich is the case? The \\mathsf{P} vs \\mathsf{NP} problem\n\n\n\n\n\nMost computer scientist believe that \\mathsf{P}\\neq \\mathsf{NP} is likely to be true (actually most computer scientists believe something stronger, see below). In any case no-one has any idea on how to prove it.\nDeciding whether \\mathsf{P}= \\mathsf{NP} or \\mathsf{P}\\neq \\mathsf{NP} is known as the \\mathsf{P} vs \\mathsf{NP} problem. It is one of the Millennium Problems of the Clay Mathematics Institute.\nRelated to the \\mathsf{P} vs \\mathsf{NP} problem are the 5 worlds by Russell Impagliazzo:\n\nAlgorithmica\n\n\\mathsf{P} = \\mathsf{NP} via some explicit algorithm or something morally equivalent like fast probabilistic algorithms for \\mathsf{NP}.\n\nHeuristica\n\n\\mathsf{NP} problems are hard in the worst case but easy on average.\n\nPessiland\n\n\\mathsf{NP} problems hard on average but no one-way functions exist. We can easily create hard \\mathsf{NP} problems, but not hard \\mathsf{NP} problems where we know the solution. This is the worst of all possible worlds, since not only can we not solve hard problems on average but we apparently do not get any cryptographic advantage from the hardness of these problems.\n\nMinicrypt\n\nOne-way functions exist but we do not have public-key cryptography.\n\nCryptomania\n\nPublic-key cryptography is possible, i.e. two parties can exchange secret messages over open channels.\n\n\nImpagliazzo does not guess which world we live in. Most computer scientists would say Cryptomania or Minicrypt."
  },
  {
    "objectID": "theory_bits/NP.html#polynomial-time-reductions",
    "href": "theory_bits/NP.html#polynomial-time-reductions",
    "title": "On NP and related concepts",
    "section": "Polynomial-time reductions",
    "text": "Polynomial-time reductions\n\nDefinition 4 Let A and B be two decisional problems with input sets I and I', respectively. We say that A reduces to B in polynomial time (A\\leq_p B) if there exists a polynomial time algorithm that computes a function f : I \\to I' such that x\\in A \\iff  f(x) \\in B.\n\nSchematically a polynomial (many-one) reduction between A_1 and and A_2 can be though as follows. Let Problem i be the problem of deciding whether an input is in A_i. A many-one reduction gives a way to construct an algorithm to solve Problem 1 given an algorithm for Problem 2 and a polynomial-time function f to convert inputs.\n\n\n\n\n\n\nTheorem 1  \n\nThe binary relation \\leq_p is a preorder (i.e. it is reflexive and transitive).\n\\mathsf{P} is closed downwards w.r.t. \\leq_p, that is if A\\leq_p B and B\\in \\mathsf{NP}, then A\\in \\mathsf{NP}.\n\\mathsf{NP} is closed downwards w.r.t. \\leq_p, that is if A\\leq_p B and B\\in \\mathsf{P}, then A\\in \\mathsf{P}.\nThe problems in \\mathsf{P} are the easiest w.r.t. \\leq_p, that is if A\\in \\mathsf{P}, then for any decision problem B it holds that A\\leq_p B."
  },
  {
    "objectID": "theory_bits/NP.html#mathsfsat-and-mathsfnp-completeness",
    "href": "theory_bits/NP.html#mathsfsat-and-mathsfnp-completeness",
    "title": "On NP and related concepts",
    "section": "\\mathsf{SAT} and \\mathsf{NP}-completeness",
    "text": "\\mathsf{SAT} and \\mathsf{NP}-completeness\n\nDefinition 5 (Propositional formula) A propositional formula is an expression involving parentheses, the constants true and false, Boolean variables x_1,…,x_n which might take values true or false, their negations \\bar x_1,…,\\bar x_n and the connectives \\lor(or, disjunction) and \\land (and, conjunction).\n\nFor example,\n\n(x\\lor y\\lor z) \\land (\\bar x\\lor \\bar z)\n is a propositional formula.\n\nDefinition 6 (satisfiable) A propositional formula F is satisfiable iff there exists an assignment of truth values to its variables such that the formula evaluates to true. For instance, the formula above is satisfiable for instance setting x= true and z= false (and y arbitrarily).\n\nNot every propositional formula is satisfiable, for instance x\\land \\bar x is not satisfiable. The set of all satisfiable propositional formulas is\n\n\\mathsf{SAT} = \\{\\varphi \\mid \\varphi \\text{ is a satisfiable propositional formula}\\}\\ .\n\n\nTheorem 2 (Cook-Levin’s Theorem) \n\\mathsf{NP} = \\{A\\mid A\\leq_p \\mathsf{SAT}\\}\\ .\n\n\n\n\n\\mathsf{NP}-complete\\mathsf{NP}-hard\n\n\nA decision problem B is \\mathsf{NP}-complete if \\mathsf{NP} = \\{A\\mid A\\leq_p B\\}. In other words, Cook-Levin’s Theorem says that \\mathsf{SAT} is \\mathsf{NP}-complete.\nThe class of all \\mathsf{NP}-complete problems is called \\mathsf{NPC}.\n\n\nIf we only know that \\mathsf{NP} \\subseteq \\{A\\mid A\\leq_p B\\}, then B is \\mathsf{NP}-hard. In particular, B is \\mathsf{NP}-complete if and only if B is \\mathsf{NP}-hard and B\\in \\mathsf{NP}.\n\n\n\n\nTheorem 3 If A\\leq_p B and A is \\mathsf{NP}-hard, then B is \\mathsf{NP}-hard.\n\nIf we believe that \\mathsf{P}\\neq  \\mathsf{NP}, then we must also believe that there are problems in \\mathsf{NP} which are neither in \\mathsf{P} nor \\mathsf{NP}-complete. This is the statement of the following theorem.\n\nTheorem 4 (Ladner’s theorem) If \\mathsf{P}\\neq  \\mathsf{NP}, then \\mathsf{NP}\\setminus (\\mathsf{P}\\cup\\mathsf{NPC})\\neq \\emptyset.\n\n Typical problems that are in \\mathsf{NP} but for which we do not know any polynomial-time algorithm and at the same time we do not know whether they are \\mathsf{NP}-complete (probably they are not) are the following:\n\ndecision versions of factoring,\nthe discrete logarithm,\nother common cryptographic assumptions."
  },
  {
    "objectID": "theory_bits/asymptotics.html",
    "href": "theory_bits/asymptotics.html",
    "title": "Asymptotic notation",
    "section": "",
    "text": "This theory bit is to recall the definition and basic properties of Big-Oh, Big-Omega, Big-Theta notation. To know if a function f is O(g) (or \\Theta(g) or \\Omega(g)) typically reduces to computing a limit. You might need to refresh how to compute limits (e.g. de L’Hôpital rule). See the theory bit on limits.\nIn this page we assume f,g to be functions from \\mathbb R \\to \\mathbb R."
  },
  {
    "objectID": "theory_bits/asymptotics.html#on-the-big-oh-notation",
    "href": "theory_bits/asymptotics.html#on-the-big-oh-notation",
    "title": "Asymptotic notation",
    "section": "On the Big-Oh notation",
    "text": "On the Big-Oh notation\n\nf grows asymptotically slower (or equal) than g\nf=O(g)\nf is Big-Oh of g\n\nhave the same meaning and are interchangeable. Formally, f is a Big-Oh of g if for all large enough x, f is at most proportional to a multiple of g. That is f=O(g) if \n\\exists x_0\\in \\mathbb R_+\\exists c\\in \\mathbb R_+\\forall x\\geq x_0\\ f(x)\\leq c\\cdot g(x)\\ .\n\nIn particular, if \\displaystyle\\lim_{x\\to \\infty}\\frac{f(x)}{g(x)}&lt; +\\infty then f=O(g)."
  },
  {
    "objectID": "theory_bits/asymptotics.html#on-the-big-omega-notation",
    "href": "theory_bits/asymptotics.html#on-the-big-omega-notation",
    "title": "Asymptotic notation",
    "section": "On the Big-Omega notation",
    "text": "On the Big-Omega notation\n\nf grows asymptotically faster (or equal) than g\nf=\\Omega(g)\nf is Big-Omega of g\n\nhave the same meaning and are interchangeable. Formally, f is a Big-Omega of g if for all large enough x, f is at at least proportional to a multiple of g. That is f=\\Omega(g) if \n\\exists x_0\\in \\mathbb R_+\\exists c\\in \\mathbb R_+\\forall x\\geq x_0\\ f(x)\\geq c\\cdot g(x)\\ .\n\nIn particular, if \\displaystyle\\lim_{x\\to \\infty}\\frac{f(x)}{g(x)}&gt; 0 then f=\\Omega(g).\nThat is, if f=O(g), then g=\\Omega(f). If f grows asymptotically slower than g, then g grows asymptotically faster than f."
  },
  {
    "objectID": "theory_bits/asymptotics.html#on-the-big-theta-notation",
    "href": "theory_bits/asymptotics.html#on-the-big-theta-notation",
    "title": "Asymptotic notation",
    "section": "On the Big-Theta notation",
    "text": "On the Big-Theta notation\n\nf has the same asymptotic growth of g\nf=\\Theta(g)\n\ng=\\Theta(f)\nf is Big-Theta of g\ng is Big-Theta of f\n\nall have the same meaning and are interchangeable. Formally, f is Big-Theta of g if it is both Big-Oh and Big-Omega of g. That is f=\\Theta(g) if \n\\exists x_0\\in \\mathbb R_+\\exists c_1,c_2\\in \\mathbb R_+\\forall x\\geq x_0\\ c_1\\cdot g(x)\\leq f(x)\\leq c_2\\cdot g(x)\\ .\n\nIn particular, if \\displaystyle\\lim_{x\\to \\infty}\\frac{f(x)}{g(x)} = c with 0&lt; c&lt;+\\infty, then f=\\Theta(g)."
  },
  {
    "objectID": "theory_bits/asymptotics.html#common-errorsconfusion",
    "href": "theory_bits/asymptotics.html#common-errorsconfusion",
    "title": "Asymptotic notation",
    "section": "Common errors/confusion",
    "text": "Common errors/confusion\nf=\\Theta(g), or f=\\Omega(g) or f=O(g) are sentences about the asymptotic growth rate of the function f in comparison with the one of g. Although f or g might be connected to algorithms (e.g. some running times), there is no reference to an algorithm implicit in the notation. In particular the \\Theta, O and \\Omega notations are not connected at all to the worst/best/average cases of the running time of algorithms.\nSometimes the practical use of the O and the \\Theta notation overlap. At times people use O(\\cdot) when they actually mean to use \\Theta(\\cdot). Recall that the O(\\cdot) notation denotes only an upper-bound on the asymptotic growth, while \\Theta(\\cdot) indicates the exact asymptotic growth rate of a function. In EDA we don’t want to do this, we try to be as precise as possible.\n\n\n\n\n\n\nExample\n\n\n\nThe sentences\n\nthe Insertion Sort algorithm in the worst case runs in time O(2^n), and\nthe Insertion Sort algorithm in the worst case runs in time in time \\Theta(n^2) \n\n(where n is the size of the input) are both technically correct sentences, but the first one is not very interesting. The first one is so little informative that actually in EDA exams might be even counted as incorrect.\n\n\n\n\n\n\n\n\nExample\n\n\n\nThe figure below is taken from the internet and summarizes visually some growth orders of functions. It is a mostly correct visual aid but not quite completely correct. Can you spot the error(s)?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe figure mixes n and x for the name of the variable. This is an easy fix, but there is another error. It would have been correct if each O(\\cdot) were a \\Theta(\\cdot).\n\n\n\n\n\n\n\nPyodide\nfrom sympy import *\nimport js\n\nvar('n', domain=RR)\n\nf = n\ng = 3*2**n\n\ndef my_print(f,g):\n    lim = limit(f/g, n, oo)\n    inv_lim = limit(g/f,n,oo)\n    print(r\"Since $\\displaystyle\\lim_{n\\to\\infty}\\frac{\",latex(f),r\"}{\",latex(g),r\"}=\",latex(lim),r\"$\")\n    if (lim &gt; 0 and inv_lim &gt; 0):\n        print(\", then $\\,\",latex(f),r\"=\\Theta(\",latex(g),\")$\")\n    elif (lim == 0):\n        print(\", then $\\,\",latex(f),r\"=O(\",latex(g),\")$\")\n    else:\n        print(\", then $\\,\",latex(f),r\"=\\Omega(\",latex(g),\")$\")\n\nmy_print(f,g)\nSince \\,\\displaystyle\\lim_{n\\to\\infty}\\frac{ n }{ 3 \\cdot 2^{n} }= 0 , then n =O( 3 \\cdot 2^{n} )"
  },
  {
    "objectID": "theory_bits/binary_search.html",
    "href": "theory_bits/binary_search.html",
    "title": "Binary Search",
    "section": "",
    "text": "Given as input an integer x and a vector v of integers ordered increasingly, i.e. v[0]\\leq v[1]\\leq v[2]\\leq \\cdots, return the position of x if it appears in the vector v (and -1 otherwise).\nThe fact that the vector is of integers is not relevant, obviously, it could be of elements of any type T, as long as T has defined an ordering on it.\ntemplate &lt;class T&gt;\n\n// Initial call: int p = BinarySearch(v, 0, v.size() - 1, x);\n\nint BinarySearch(const vector&lt;T&gt;& v, int left, int right, T x){\n    if (left &gt; right) return -1;\n    int mid = (left + right) / 2;\n    if (x &lt; v[mid]) \n        return BinarySearch(v, left, mid - 1, x);\n    if (x &gt; v[mid]) \n        return BinarySearch(v, mid + 1, right, x);\n    return mid;\n}\n\n\n\n\n\n\nFirst occurrence?\n\n\n\nDoes the code above find the first occurrence of x in v? If not, how can you modify it so that it does?\nYou might want to solve the Jutge.org exercise P84219 First occurrence.\n\n\nThe worst case running time T(n) of BinarySearch on an input of size n satisfies the recurrence\n\nT(n)=T\\left(\\frac{n}{2}\\right)+\\Theta(1)\n\nwhich, by the Master Theorem, gives T(n)=\\Theta(\\log n).\nThis is actually the best possible among all comparison-based search algorithms. A comparison-based search algorithm, searching for an element x in a vector v, is only allowed to interact with v by asking questions of the form\n\n“is x&gt;v[i]?” or\n“is x=v[i]?”, or\n“is x &lt; v[i]?”,\n\nand getting a YES/NO answer.\n\n\n\n\n\n\nTheorem\n\n\n\nAny deterministic comparison-based searching algorithm must perform \\Omega(\\log n) comparisons in the worst case to search for an element in a vector of size n.\n\n\nThe proof of the theorem above is similar to the one used to show the lower bound on the \\Omega(n\\log n) worst case running time of any comparison-based sorting algorithm, and it is left as an exercise."
  },
  {
    "objectID": "theory_bits/graphs.html",
    "href": "theory_bits/graphs.html",
    "title": "Graphs",
    "section": "",
    "text": "A graph is a structure in which pairs of vertices are connected by edges. Each edge may act like an ordered pair (in a directed graph) or an unordered pair (in an undirected graph).\nThe typical notation for an undirected graph is G=(V,E), where V is a set of vertices, and E\\subseteq \\binom{V}{2} are the edges. For a directed graph (with loops), the notation is the same G=(V,E), but the set of edges E\\subseteq V\\times V. The complexity of an algorithm on graphs is usually measured as a function of |V| and |E|. For a finite graph G=(V,E) typically n=|V| and m=|E|. Notice that for every finite graph |E|\\leq |V|^2, i.e. m\\leq n^2.\nGenerally, the vertex set V is taken to be finite (which implies that the edge set E is also finite). Sometimes infinite graphs are considered, but they are usually viewed as a special kind of binary relation, because most results on finite graphs either do not extend to the infinite case or need a rather different proof.\nGiven a family of graphs G_n=(V_n,E_n), the family is dense if for any n, |E_n|= \\Theta(|V_n|^2). Otherwise it is called sparse.\nFor instance, the family of complete graphs K_n is dense, while the family of cyclic graphs C_n and the family of grid graphs G_n are sparse.\nFor an edge e= (u,v), the vertex u is called the source and a vertex v the target. We say that v is a successor of u; conversely, u is a predecessor of v. For an undrected edge e= \\{u,v\\}, the vertices are called its extremes and we say u and v are adjacent. We also say that the edge e is incident to u and v.\nThe vertices adjacent to a vertex u are its neighbors, and the collection of them is the set N(u). The number of edges incident to a vertex u (equivalently, the number of vertices v adjacent to u) is called the degree of u and it is denoted with \\deg(u). In other words, \\deg(u)=|N(v)|. One important identity is that for every graph G=(V,E),\n\\sum_{v\\in V}\\deg(v)=2|E|\\ .\\tag{Handshaking Lemma}\nA graph is called d-regular if all the vertices have the same degree d. In particular, a d-regular graph with n vertices has \\frac{dn}{2} many edges. For instance, the complete graph K_n is (n-1)-regular. For d constant, the family of d-regular graphs is sparse."
  },
  {
    "objectID": "theory_bits/graphs.html#paths-and-connectivity",
    "href": "theory_bits/graphs.html#paths-and-connectivity",
    "title": "Graphs",
    "section": "1 Paths and connectivity",
    "text": "1 Paths and connectivity\nA path P of length \\ell in a graph G=(V,E) is a sequence of \\ell+1 vertices v_0, v_1, v_2, \\dots, v_\\ell such that any two consecutive vertices in the sequence are connected by an edge. The vertex v_0 is the starting point or origin of P and v_\\ell the ending point or target. A path is called simple if no vertex appears more than once in the sequence, except possibly v_0 and v_\\ell. If v_0=v_\\ell we say that the simple path is a cycle.\nA graph G= (V,E) is connected if and only if for every pair of vertices u,v\\in V there exists a path in G starting in u and ending in v.\n\nEulerian path\n\na path that contains all edges of the graph\n\nHamiltonian path\n\na path that touches all vertices of the graph\n\n\nGiven a graph G is there an Eulerian path in it? Or is there a Hamiltonian path in it? Although superficially similar the two questions are very different. It is easy to decide if a graph G has an Eulerian path: indeed, it can be proven that G has an Eulerian path iff G is connected and there are either 0 or 2 vertices with odd degree.\nOn the other hand, it is conjecturally difficult (in a precise sense you will see later in the course) to decide whether a graph G has a Hamiltonian path."
  },
  {
    "objectID": "theory_bits/graphs.html#representation-of-graphs",
    "href": "theory_bits/graphs.html#representation-of-graphs",
    "title": "Graphs",
    "section": "2 Representation of Graphs",
    "text": "2 Representation of Graphs\nThe two most frequent ways to implement a graph are via adjacency matrices or adjacency lists. As a general rule, the preferred implementation will be adjancecy lists.\n\nAdjancency matricesAdjancency lists\n\n\nThe graph G=(V,E) is represented using a matrix, called the adjacency matrix A with Boolean entries: the entry A[i][j] of the adjancency matrix A is a Boolean indicating whether (i,j) is an edge in E or not.\nFor weighted (directed) graph, the entry A[i][j] stores the label/weight assigned to the edge (i,j).\n\nPro\n\nwe can answer very efficiently whether an edge (u,v) \\in E or not. Moreover, linear algebra calculations on A reveal properties of the underlying graph. For instance, \\frac{1}{6}\\mathrm{tr}(A^3) is the number of triangles in G, or, when G is undirected, then A is symmetric and hence by the spectral theorem it has real eigenvuales \\lambda_1\\geq \\lambda_2\\geq \\dots\\geq \\lambda_n. When G is d-regular, then \\lambda_1=d, and d-\\lambda_2 measures expansion properties of G which are important in several contexts.\n\nCons\n\ncostly in space. The space is always \\Theta(|V|^2), regardless of the number of edges. This would be fine if G is dense. It is slow to add/delete a node |\\Theta(|V|^2) (but is fast to add a new edge \\Theta(1)).\n\n\n\n\nThe graph G=(V,E) is represented using an array or vector of lists. We use an array or vector L such that for a vertex u\\in V, L[u] points to a list of the vertices v\\in V which are adjacent to u, or a list of the edges incident to u.\nFor directed graphs, we will have the list of the successors of a vertex u, for all vertices u, and, possibly, the list of predecessors of a vertex u, for all vertices u.\n\nPro\n\nrequire space \\Theta(|V|+|E|), i.e. linear in the size of the graph. Moreover, they are easy to modify/implement.\n\nCons\n\nQueries like whether there is an edge from vertex u to vertex v are not efficient and might require time complexity \\Theta(|V|) (depending on the graph stored). An adjacency list might not suitable when the graph is dense or to compute algebraic invariants of graphs."
  },
  {
    "objectID": "theory_bits/graphs.html#bfsdfs",
    "href": "theory_bits/graphs.html#bfsdfs",
    "title": "Graphs",
    "section": "3 BFS/DFS",
    "text": "3 BFS/DFS"
  },
  {
    "objectID": "theory_bits/heaps.html",
    "href": "theory_bits/heaps.html",
    "title": "Heaps",
    "section": "",
    "text": "A binary tree is complete if all leaves are at the same level.\nA quasi-complete binary tree of depth d is a binary tree is such that up to depth d-1 it is a perfect binary tree and all the leaves at depth d are accumulated on the left as much as possible.\n\n\n\n\n\n\nDepth of (quasi-)complete trees\n\n\n\nA complete binary tree of depth d has exactly 2^{d+1}-1 nodes.\nA quasi-complete binary tree of depth d has between 2^d and 2^{d+1}-1 vertices.\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\nIn a complete tree there is 1 vertex at depth 0 (the root itself), 2 vertices at depth 1, 4 vertices at depth 2, …, 2^i vertices at depth i. So in total, a complete tree of depth d has 1+2+2^2+\\cdots +2^d=2^{d+1}-1 many vertices.\nFor a quasi complete-tree it is the same: up to depth d-1 there are exactly 2^d-1 many vertices. To have a tree of depth d there must be at least 1 vertex at depth d. So the total number of vertices is between 2^d and 2^{d+1}-1.\n\n\n\nIn other words: the depth of a (quasi-)complete binary tree with n vertices is \\lceil \\log_2(n+1)\\rceil, i.e \\Theta(\\log n).\n\n\nWe could implement quasi-complete trees with dynamically allocated nodes, and three pointers per node (left, right, father)… But it is much easier and efficient to implement them with vectors!\nTo make the rules easier, to store a quasi-complete tree with n vertices we use a vector A of size n+ 1 and discard A[0]:\n\nA[1] contains the root\nIf 2i\\leq n then A[2i] contains the left child of A[i] and if 2i+ 1 \\leq n then A[2i+ 1] contains the right child of A[i].\n\nIn other words, for each i\\geq 2, the father of A[i] is A[\\lfloor i/2\\rfloor].\n\n\n\n\n\n\nNumber of leaves in a quasi-complete tree\n\n\n\nA quasi-complete tree with n vertices has \\lceil \\frac{n}{2}\\rceil leaves.\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\nIt is easier to see when the quasi-complete tree is stored in a vector. The last leaf of tree is the nthe element of the vector. Its father is in position \\lfloor \\frac{n}{2}\\rfloor. That is, all the n-\\lfloor \\frac{n}{2}\\rfloor many elements in the vector after the father of the last leaf must be leaves aswell, and all the elements before the one in position \\lfloor \\frac{n}{2}\\rfloor cannot be leaves. Since n-\\lfloor \\frac{n}{2}\\rfloor=\\lceil \\frac{n}{2}\\rceil this concludes the proof."
  },
  {
    "objectID": "theory_bits/heaps.html#complete-and-quasi-complete-trees",
    "href": "theory_bits/heaps.html#complete-and-quasi-complete-trees",
    "title": "Heaps",
    "section": "",
    "text": "A binary tree is complete if all leaves are at the same level.\nA quasi-complete binary tree of depth d is a binary tree is such that up to depth d-1 it is a perfect binary tree and all the leaves at depth d are accumulated on the left as much as possible.\n\n\n\n\n\n\nDepth of (quasi-)complete trees\n\n\n\nA complete binary tree of depth d has exactly 2^{d+1}-1 nodes.\nA quasi-complete binary tree of depth d has between 2^d and 2^{d+1}-1 vertices.\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\nIn a complete tree there is 1 vertex at depth 0 (the root itself), 2 vertices at depth 1, 4 vertices at depth 2, …, 2^i vertices at depth i. So in total, a complete tree of depth d has 1+2+2^2+\\cdots +2^d=2^{d+1}-1 many vertices.\nFor a quasi complete-tree it is the same: up to depth d-1 there are exactly 2^d-1 many vertices. To have a tree of depth d there must be at least 1 vertex at depth d. So the total number of vertices is between 2^d and 2^{d+1}-1.\n\n\n\nIn other words: the depth of a (quasi-)complete binary tree with n vertices is \\lceil \\log_2(n+1)\\rceil, i.e \\Theta(\\log n).\n\n\nWe could implement quasi-complete trees with dynamically allocated nodes, and three pointers per node (left, right, father)… But it is much easier and efficient to implement them with vectors!\nTo make the rules easier, to store a quasi-complete tree with n vertices we use a vector A of size n+ 1 and discard A[0]:\n\nA[1] contains the root\nIf 2i\\leq n then A[2i] contains the left child of A[i] and if 2i+ 1 \\leq n then A[2i+ 1] contains the right child of A[i].\n\nIn other words, for each i\\geq 2, the father of A[i] is A[\\lfloor i/2\\rfloor].\n\n\n\n\n\n\nNumber of leaves in a quasi-complete tree\n\n\n\nA quasi-complete tree with n vertices has \\lceil \\frac{n}{2}\\rceil leaves.\n\n\n\n\n\n\n\n\nProof\n\n\n\n\n\nIt is easier to see when the quasi-complete tree is stored in a vector. The last leaf of tree is the nthe element of the vector. Its father is in position \\lfloor \\frac{n}{2}\\rfloor. That is, all the n-\\lfloor \\frac{n}{2}\\rfloor many elements in the vector after the father of the last leaf must be leaves aswell, and all the elements before the one in position \\lfloor \\frac{n}{2}\\rfloor cannot be leaves. Since n-\\lfloor \\frac{n}{2}\\rfloor=\\lceil \\frac{n}{2}\\rceil this concludes the proof."
  },
  {
    "objectID": "theory_bits/heaps.html#heaps",
    "href": "theory_bits/heaps.html#heaps",
    "title": "Heaps",
    "section": "Heaps",
    "text": "Heaps\nA max-heap (resp. min-heap) is a quasi-complete binary tree such that the label of any vertex is larger (resp. smaller) or equal than the label of any of its descendants.\nIt is easy to see that the root of a max-heap has the largest label among all the vertices in the heap.\nIf a max-heap is used to implement a max prioprity queue the query for a max element and its priority is trivial: we need only to examine the root of the heap.\n\nRemoving the maximumAdding a new elementConstructing a max-heap\n\n\n\nReplace the root of the heap with the last element (the rightmost element in the last level)\nRe-establish the order sinking the new root: compare the given node to its child with largest label, and they are exchanged if its label is smaller than that of its child; the process is repeated until the order is reestablished.\n\n\n\n\nAdd the new element as rightmost node of the last level of the heap (or as the first element of a new deeper level)\nRe-establish the order floating the new added element: compare the given node to its father, and they are exchanged if its label is larger than that of its father; the process is repeated until the order is reestablished.\n\n\n\nThe following code sketches how to construct a max-heap on a vector with n elements\n// Establish a max-heap order in the\n// array v[1..n] of Elem’s; Elem == priorities\ntemplate &lt;typename Elem&gt;\nvoid heapify(Elem v[], int n) {\nfor (int i = n/2; i &gt; 0; --i)\nsink(v, n, i);//sinks the element in position i to find its place in the vector\n}\nClearly this takes time at least \\Omega(n). For an upper bound, consider that the cost for sinking the ith element is O(\\log(n/i)). So globally the cost of the algorithm to construct a max-heap is \n\\sum_{i=1}^{\\lfloor n/2\\rfloor} O(\\log(n/i))=O\\left(\\sum_{i=1}^{\\lfloor n/2\\rfloor} \\log(n/i)\\right)=O\\left(\\log \\frac{n^{n/2}}{(n/2)!}\\right)\n= O(n)\n Therefor the cost of constructing a max-heap is \\Theta(n).\n\n\n\nSince the height of a heap is \\Theta(\\log n), the cost of removing the maximum and the cost of insertions is \\Theta(\\log n).\n\nHeapsort\nThe sorting algorithm Heapsort (Williams, 1964) sorts an array of n elements building a min-heap with the n elements and extracting them, one by one, from the heap.\nThe originally given array is used to build the heap; heapsort works in-place and only some constant auxiliary memory space is needed. Since insertions and deletions in heaps have cost O(\\log n) the cost of the algorithm is O(n\\log n).\nFor a comparison of Heap-sort with other comparison-based sorting algorithms see this page."
  },
  {
    "objectID": "theory_bits/limits.html",
    "href": "theory_bits/limits.html",
    "title": "Limits",
    "section": "",
    "text": "Given two functions f,g: \\mathbb R\\to \\mathbb R, I’m assuming you are already familiar with how to compute \\displaystyle \\lim_{x\\to +\\infty}\\frac{f(x)}{g(x)}. For instance, whether the limit exists or the indeterminate forms \\frac{0}{0}, \\frac{\\infty}{\\infty}. This theory bit only recalls de l’Hôpital’s rule, and give some tools to compute limits in a Computer Algebra System."
  },
  {
    "objectID": "theory_bits/limits.html#de-lhôpitals-rule",
    "href": "theory_bits/limits.html#de-lhôpitals-rule",
    "title": "Limits",
    "section": "De l’Hôpital’s rule",
    "text": "De l’Hôpital’s rule\n\n\n\n\n\n\nTheorem (De l’Hôpital’s rule)\n\n\n\nFor differentiable functions f,g: [a,+\\infty)\\to \\mathbb R, if\n\n\\displaystyle\\lim_{x\\to+\\infty} f(x)=\\lim_{x\\to+\\infty} g(x)=0 or \\pm \\infty,\ng'(x)\\neq 0 in the whole interval [a,+\\infty), and\n\\displaystyle\\lim_{x\\to+\\infty}\\frac{f'(x)}{g'(x)} exists\n\nthen \n\\lim_{x\\to+\\infty}\\frac{f(x)}{g(x)}=\\lim_{x\\to+\\infty}\\frac{f'(x)}{g'(x)}\\ .\n\n\n\nThis is not the most general statement of De l’Hôpital’s rule, but it is the statement we will use in computing the asymptotic behaviour of functions."
  },
  {
    "objectID": "theory_bits/limits.html#limits-in-sagemath",
    "href": "theory_bits/limits.html#limits-in-sagemath",
    "title": "Limits",
    "section": "Limits in SageMath",
    "text": "Limits in SageMath\nThere are several CAS (Computer Algebra Systems) that allow to perform exact symbolic computations. Some examples are SymPy, Maxima, or Mathematica (among many others). Each has its own slightly different syntax and they are all extremely useful to automate routine calculations such as limits, derivatives, integration, and matrix operations (among a lot of other things).\nIn this course you need to be able to compute limits step-by-step and justify your calculations, but: you might want to use some CAS to double-check the correctness of your calculations. Treat CASs as being 90% correct, that is they might be wrong but it is quite unlikely.\nFor instance, we can use SageMath to compute limits as in the following example.\n\n\n\n\n\n\nExample\n\n\n\nSuppose we want to compute \\displaystyle\\lim_{x\\to\\infty}\\frac{f(x)}{g(x)} for f(x)=2^{\\sqrt{\\log(x)}} and g(x)=\\sqrt{x}. In SageMath this could be done as follows.\n\n\n\n\n\nThe following table recaps the syntax of common functions in SageMath.\n\n\n\n\n\n\n\nFunction\nRepresentation in SageMath\n\n\n\n\ne^x\ne^x or exp(x)\n\n\n2^x\n2^x\n\n\n\\displaystyle\\frac{3x^2+4x^{1/3}+2}{x+1}\n(3*x^2 + 4*x^(1/3) + 2)/(x+1)\n\n\n\\ln(x)\nlog(x)\n\n\n\\log_2(x)\nlog(x,2)\n\n\n\\sqrt{x}\nsqrt(x)\n\n\nx!\nfactorial(x)\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nDo not use n as the name of your variable, since this would tell SageMath to treat it as an integer. In our context, this would only create problems. Use x instead.\n\n\nExercise: Use SageMath to verify Stirling’s approximation, i.e. that the ratio of x! with \\sqrt{x}\\left(\\frac{x}{e}\\right)^x tends to a constant when x\\to \\infty."
  },
  {
    "objectID": "theory_bits/master_theorem.html",
    "href": "theory_bits/master_theorem.html",
    "title": "The Master Theorem(s)",
    "section": "",
    "text": "Master Theorem Subtract-and-Conquer\n\n\n\nGiven the recurrence \nT(n)=\n\\begin{cases}\ng(n) & \\text{if } 0\\leq n &lt; n_0\\ ,\\\\\na\\cdot T(n-b)+ f(n) &\\text{if } n \\geq n_0\\ ,\n\\end{cases}\n with a,b, n_0, \\gamma all non-negative constants, g an arbitrary function and f(n)=\\Theta(n^\\gamma), the closed form of T is\n\nT(n)=\n\\begin{cases}\n\\Theta(n^\\gamma) &\\text{if } a &lt; 1\\ ,\\\\\n\\Theta(n^{\\gamma+1})&\\text{if } a = 1\\ ,\\\\\n\\Theta(a^{n/b})&\\text{if } a &gt; 1\\ .\n\\end{cases}\nThe statement above still holds if instead of \\frac{n}{b} in the recurrence, there is any function in \\frac{n}{b}+O(1), for instance \\lceil \\frac{n}{b}\\rceil or \\lfloor \\frac{n}{b}\\rfloor.1\nIn particular, the recurrence giving the worst case running time of the MergeSort algorithm, i.e.\nT(n)=T\\left(\\left\\lfloor\\frac{n}{2}\\right\\rfloor\\right)+T\\left(\\left\\lceil\\frac{n}{2}\\right\\rceil\\right)+\\Theta(n)\nand the recurrence\nS(n)=2S\\left(\\frac{n}{2}\\right)+\\Theta(n)\nboth have the same solution, i.e. T(n)=S(n)=\\Theta(n\\log n). Btw, no comparison-based sorting algorithm could have a wort case running time better than \\Theta(n\\log n)."
  },
  {
    "objectID": "theory_bits/master_theorem.html#footnotes",
    "href": "theory_bits/master_theorem.html#footnotes",
    "title": "The Master Theorem(s)",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThis is a consequence of the Akra-Bazzi Theorem, a generalization of the Master Theorem used to handle much more general forms of recurrences.↩︎"
  }
]